<!DOCTYPE html>
<html lang="ru" dir="ltr">
<head>
  <meta charset="utf-8" />
  <title>ru:gamedev:documentation</title>
<meta name="generator" content="DokuWiki"/>
<meta name="robots" content="noindex,nofollow"/>
<meta name="date" content="2013-01-24T12:17:59+0400"/>
<meta name="keywords" content="ru,gamedev,documentation"/>
<link rel="search" type="application/opensearchdescription+xml" href="/wiki/lib/exe/opensearch.php" title="instead-wiki"/>
<link rel="start" href="/wiki/"/>
<link rel="contents" href="/wiki/ru/gamedev/documentation?do=index" title="Все страницы"/>
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="/wiki/feed.php"/>
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="/wiki/feed.php?mode=list&amp;ns=ru:gamedev"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="/wiki/_export/xhtml/ru/gamedev/documentation"/>
<link rel="alternate" type="text/plain" title="Wiki Markup" href="/wiki/_export/raw/ru/gamedev/documentation"/>
<link rel="canonical" href="http://instead.syscall.ru/wiki/ru/gamedev/documentation"/>
<link rel="stylesheet" type="text/css" href="/wiki/lib/exe/css.php?t=vector&amp;tseed=1358764403"/>
<link rel="stylesheet" type="text/css" href="/wiki/lib/plugins/syntaxhighlighter3/sxh3/styles/shCore.css"/>
<link rel="stylesheet" type="text/css" href="/wiki/lib/plugins/syntaxhighlighter3/sxh3/styles/shThemeDefault.css"/>
<script type="text/javascript">/*<![CDATA[*/var NS='ru:gamedev';var JSINFO = {"id":"ru:gamedev:documentation","namespace":"ru:gamedev"};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="/wiki/lib/exe/js.php?tseed=1358764403"></script>
<script type="text/javascript" src="/wiki/lib/plugins/syntaxhighlighter3/sxh3/scripts/shCore.js"></script>
<script type="text/javascript" src="/wiki/lib/plugins/syntaxhighlighter3/sxh3/scripts/shAutoloader.js"></script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle">Содержание</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="#общие_сведения">0. Общие сведения</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="#история_создания">История создания</a></div></li>
<li class="level2"><div class="li"><a href="#как_выглядит_классическая_instead_игра">Как выглядит классическая INSTEAD игра</a></div></li>
<li class="level2"><div class="li"><a href="#как_создавать_игру">Как создавать игру</a></div></li>
<li class="level2"><div class="li"><a href="#основы_отладки">Основы отладки</a></div></li>
</ul>
</li>
<li class="level1"><div class="li"><a href="#сцена">1. Сцена</a></div></li>
<li class="level1"><div class="li"><a href="#объекты">2. Объекты</a></div></li>
<li class="level1"><div class="li"><a href="#добавляем_объекты_в_сцену">3. Добавляем объекты в сцену</a></div></li>
<li class="level1"><div class="li"><a href="#объекты_связанные_с_другими_объектами">4. Объекты, связанные с другими объектами</a></div></li>
<li class="level1"><div class="li"><a href="#атрибуты_и_обработчики_как_функции">5. Атрибуты и обработчики как функции</a></div></li>
<li class="level1"><div class="li"><a href="#инвентарь">6. Инвентарь</a></div></li>
<li class="level1"><div class="li"><a href="#переходы_между_сценами">7. Переходы между сценами</a></div></li>
<li class="level1"><div class="li"><a href="#действие_объектов_друг_на_друга">8. Действие объектов друг на друга</a></div></li>
<li class="level1"><div class="li"><a href="#объект_player">9. Объект &quot;player&quot;</a></div></li>
<li class="level1"><div class="li"><a href="#объект_game">10. Объект &#039;&#039;game&#039;&#039;</a></div></li>
<li class="level1"><div class="li"><a href="#атрибуты-списки">11. Атрибуты-списки</a></div></li>
<li class="level1"><div class="li"><a href="#функции_которые_возвращают_объекты">12. Функции, которые возвращают объекты</a></div></li>
<li class="level1"><div class="li"><a href="#другие_функции_instead">13. Другие функции INSTEAD</a></div></li>
<li class="level1"><div class="li"><a href="#диалоги">14. Диалоги</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="#расширенные_диалоги">Расширенные диалоги</a></div></li>
<li class="level2"><div class="li"><a href="#простые_диалоги">Простые диалоги</a></div></li>
</ul>
</li>
<li class="level1"><div class="li"><a href="#облегченные_объекты">15. Облегченные объекты</a></div></li>
<li class="level1"><div class="li"><a href="#динамические_события">16. Динамические события</a></div></li>
<li class="level1"><div class="li"><a href="#графика">17. Графика</a></div></li>
<li class="level1"><div class="li"><a href="#музыка">18. Музыка</a></div></li>
<li class="level1"><div class="li"><a href="#форматирование_и_оформление_вывода">19. Форматирование и оформление вывода</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="#форматирование">Форматирование</a></div></li>
<li class="level2"><div class="li"><a href="#оформление">Оформление</a></div></li>
</ul>
</li>
<li class="level1"><div class="li"><a href="#конструкторы_и_наследование">20. Конструкторы и наследование</a></div></li>
<li class="level1"><div class="li"><a href="#полезные_советы">21. Полезные советы</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="#разбиение_на_файлы">Разбиение на файлы</a></div></li>
<li class="level2"><div class="li"><a href="#модули">Модули</a></div></li>
<li class="level2"><div class="li"><a href="#меню">Меню</a></div></li>
<li class="level2"><div class="li"><a href="#статус_игрока">Статус игрока</a></div></li>
<li class="level2"><div class="li"><a href="#walk_из_обработчиков_exit_и_enter">walk из обработчиков exit и enter</a></div></li>
<li class="level2"><div class="li"><a href="#динамически_создаваемые_ссылки">Динамически создаваемые ссылки.</a></div></li>
<li class="level2"><div class="li"><a href="#кодирование_исходного_кода_игры">Кодирование исходного кода игры</a></div></li>
<li class="level2"><div class="li"><a href="#запаковка_ресурсов">Запаковка ресурсов</a></div></li>
<li class="level2"><div class="li"><a href="#переключение_между_игроками">Переключение между игроками</a></div></li>
<li class="level2"><div class="li"><a href="#использование_параметров_обработчика">Использование параметров обработчика</a></div></li>
<li class="level2"><div class="li"><a href="#таймер">Таймер</a></div></li>
<li class="level2"><div class="li"><a href="#музыкальный_плеер">Музыкальный плеер</a></div></li>
<li class="level2"><div class="li"><a href="#живые_объекты">Живые объекты</a></div></li>
<li class="level2"><div class="li"><a href="#клавиатура">Клавиатура</a></div></li>
<li class="level2"><div class="li"><a href="#мышь">Мышь</a></div></li>
<li class="level2"><div class="li"><a href="#вызов_меню">Вызов меню</a></div></li>
<li class="level2"><div class="li"><a href="#динамическое_создание_объектов">Динамическое создание объектов</a></div></li>
<li class="level2"><div class="li"><a href="#запрет_на_сохранение_игры">Запрет на сохранение игры</a></div></li>
</ul>
</li>
<li class="level1"><div class="li"><a href="#темы_для_sdl-instead">22. Темы для sdl-instead</a></div></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 class="sectionedit1" id="общие_сведения">0. Общие сведения</h1>
<div class="level1">

<p>
Код игр под INSTEAD пишется на <em>lua (5.1 или 5.2)</em>, поэтому, знание этого языка полезно, хотя и не необходимо. Ядро движка также написано на lua, поэтому знание lua может быть полезным для углубленного понимания принципов его работы, конечно, при условии, если вам интересно этим заниматься.
</p>

<p>
За время своего развития, INSTEAD получил множество новых функций. Теперь с его помощью можно делать игры разных жанров (от аркад, до игр с текстовым вводом). А также, в INSTEAD можно запускать игры, написанные на некоторых других движках, но основой INSTEAD остается первоначальное ядро, которое ориентировано на создание текстографических приключенческих игр. В данной документации описана именно эта базовая часть, изучение которой необходимо даже в том случае, если вы хотите написать что-то другое… Начните свое изучение INSTEAD с написания простой игры!
</p>
<div class="wrap_center wrap_round wrap_info plugin_wrap">
<p>
<em class="u">Внимание!</em>
</p>

<p>
Самая свежая документация всегда находится по адресу:<br/>

<a href="http://instead.syscall.ru/wiki/ru/gamedev/documentation" class="urlextern" title="http://instead.syscall.ru/wiki/ru/gamedev/documentation"  rel="nofollow">http://instead.syscall.ru/wiki/ru/gamedev/documentation</a>
</p>

<p>
В формате pdf:
</p>

<p>
<a href="http://instead.googlecode.com/svn/trunk/doc/instead-manual.pdf" class="urlextern" title="http://instead.googlecode.com/svn/trunk/doc/instead-manual.pdf"  rel="nofollow">http://instead.googlecode.com/svn/trunk/doc/instead-manual.pdf</a><br/>

<a href="http://instead.googlecode.com/svn/trunk/doc/instead-modules.pdf" class="urlextern" title="http://instead.googlecode.com/svn/trunk/doc/instead-modules.pdf"  rel="nofollow">http://instead.googlecode.com/svn/trunk/doc/instead-modules.pdf</a>
</p>

<p>
Если у вас возникают вопросы, вы можете зарегистрироваться на форуме INSTEAD и задавать их там: 
</p>

<p>
<a href="http://instead.syscall.ru/forum" class="urlextern" title="http://instead.syscall.ru/forum"  rel="nofollow">http://instead.syscall.ru/forum</a>
</p>

<p>
Также, вы можете посетить Jabber конференцию: instead@conference.jabber.ru
</p>

<p>
Следующие ресурсы также могут быть полезными:
</p>
<ul>
<li class="level1"><div class="li"> Обучающая игра: <a href="http://instead.syscall.ru/wiki/ru/gamedev/dive-into-instead" class="urlextern" title="http://instead.syscall.ru/wiki/ru/gamedev/dive-into-instead"  rel="nofollow">http://instead.syscall.ru/wiki/ru/gamedev/dive-into-instead</a></div>
</li>
<li class="level1"><div class="li"> Instead: вводный курс: <a href="http://forum.ifiction.ru/viewtopic.php?id=1867" class="urlextern" title="http://forum.ifiction.ru/viewtopic.php?id=1867"  rel="nofollow">http://forum.ifiction.ru/viewtopic.php?id=1867</a></div>
</li>
</ul>
</div>
</div>
<!-- EDIT1 SECTION "0. Общие сведения" [2-2497] -->
<h2 class="sectionedit2" id="история_создания">История создания</h2>
<div class="level2">

<p>
Когда мы говорим «текстовое приключение» у большинства людей возникает один из двух привычных образов. Это либо текст с кнопками действий, например:
</p>
<pre class="code">Вы видите перед собой стол. На столе лежит яблоко. Что делать?

1) Взять яблоко
2) Отойти от стола</pre>

<p>
Или, гораздо реже, это классические игры с текстовым вводом, где для управления игрой необходимо было вводить действия с клавиатуры.
</p>
<pre class="code">Вы на кухне. Тут есть стол.
&gt; осмотреть стол.
На столе есть яблоко.</pre>

<p>
У обоих подходов есть свои преимущества и недостатки. 
</p>

<p>
Если говорить про первый подход, то он близок к жанру книг-игр и удобен больше для литературных текстов, которые описывают события, происходящие с главным героем, и не очень удобен для создания классических квестов, где главный герой исследует смоделированный в игре мир, свободно перемещаясь по нему и взаимодействуя с объектами этого мира.
</p>

<p>
Второй подход моделирует мир, но требует значительных усилий от автора игры, и, что более важно, более подготовленного игрока. Особенно, когда мы имеем дело с русским языком.
</p>

<p>
Проект INSTEAD был создан для написания другого типа игр, которые совмещают преимущества обоих подходов, одновременно пытаясь избежать их недостатков.
</p>

<p>
Мир игры на INSTEAD моделируется как при втором подходе, то есть в игре есть места (сцены) которые может посещать главный герой и объекты, с которыми он взаимодействует (включая живых персонажей). Игрок свободно изучает мир и манипулирует объектами. Причем, действия с объектами не прописаны в виде явных пунктов меню, а скорее напоминают классические графические квесты в стиле 90-х.
</p>

<p>
На самом деле, в INSTEAD есть множество незаметных на первый взгляд вещей, которые направлены на развитие выбранного подхода, и который делает процесс игры максимально динамичным и непохожим на привычные «текстовые квесты». Это подтверждается в том числе и тем, что на движке было выпущено множество замечательных игр, интерес к которым проявляют не только любители текстовых игр как таковых, но и люди не знакомые с данным жанром.
</p>

<p>
Перед изучением данного руководства, я рекомендую поиграть в классические игры INSTEAD, чтобы понять о чем идет речь. С другой стороны, раз вы здесь, то наверное вы уже сделали это.
</p>

<p>
Правда, не стоит пока изучать код этих игр, так как старые игры очень часто написаны неоптимально,
с использованием устаревших конструкций. Текущая версия INSTEAD позволяет реализовывать код
лаконичнее, проще и понятнее. Об этом и рассказывается в данном документе.
</p>

<p>
Если вас интересует история создания движка, то вы можете прочитать статью о том, как все начиналось:  <a href="http://instead.syscall.ru/2010/05/history" class="urlextern" title="http://instead.syscall.ru/2010/05/history"  rel="nofollow">http://instead.syscall.ru/2010/05/history</a>
</p>

</div>
<!-- EDIT2 SECTION "История создания" [2498-7207] -->
<h2 class="sectionedit3" id="как_выглядит_классическая_instead_игра">Как выглядит классическая INSTEAD игра</h2>
<div class="level2">

<p>
Итак, как выглядит классическая INSTEAD игра? 
</p>

<p>
<em>Главное окно</em> игры содержит информацию о статической и динамической части сцены, активные события и картинку сцены с возможными переходами в другие сцены (в графическом интерпретаторе).
</p>

<p>
<em>Статическая часть сцены</em> отображается только один раз, при показе сцены, или при повторении команды <code>look</code> (в графическом интерпретаторе – клик на названии сцены).
<em>

Динамическая часть сцены</em> составлена из описаний объектов сцены, она отображается всегда.
</p>

<p>
Игроку доступны объекты, доступные на любой сцене – <em>инвентарь</em>. Игрок может взаимодействовать с объектами инвентаря и действовать объектами инвентаря на другие объекты сцены или инвентаря.
</p>
<div class="wrap_center wrap_round wrap_info plugin_wrap">
<p>
Следует отметить, что понятие инвентаря является условным. Например, в «инвентаре» могут находиться такие объекты как «открыть», «осмотреть», «использовать» и т.д.
</p>
</div>
<p>
<em>Действиями</em> игрока могут быть:
</p>
<ul>
<li class="level1"><div class="li"> осмотр сцены;</div>
</li>
<li class="level1"><div class="li"> действие на объект сцены;</div>
</li>
<li class="level1"><div class="li"> действие на объект инвентаря;</div>
</li>
<li class="level1"><div class="li"> действие объектом инвентаря на объект сцены;</div>
</li>
<li class="level1"><div class="li"> действие объектом инвентаря на объект инвентаря;</div>
</li>
<li class="level1"><div class="li"> действие объектом сцены на объект сцены (режим scene_use);</div>
</li>
<li class="level1"><div class="li"> действие объектом сцены на инвентарь (режим scene_use);</div>
</li>
<li class="level1"><div class="li"> переход в другую сцену.</div>
</li>
</ul>

</div>
<!-- EDIT3 SECTION "Как выглядит классическая INSTEAD игра" [7208-9489] -->
<h2 class="sectionedit4" id="как_создавать_игру">Как создавать игру</h2>
<div class="level2">

<p>
Игра представляет из себя каталог, в котором должен находиться скрипт (текстовый файл) <code>main.lua</code>. Другие ресурсы игры (скрипты на <code>lua</code>, графика и музыка) должны находиться в рамках этого каталога. Все ссылки на ресурсы делаются относительно текущего каталога – каталога игры.
</p>

<p>
В начале файла <code>main.lua</code> может быть определен заголовок, состоящий из тегов (строк специального вида). Теги должны начинаться с символов <code>--</code>: комментарий с точки зрения lua. На данный момент существует три тега.
</p>

<p>
Тег <code>$Name:</code> содержит название игры в кодировке UTF-8. Пример использования тега:
</p>
<pre class="code lua"><span class="co1">-- $Name: Самая интересная игра!$</span></pre>

<p>
Затем следует (желательно) задать версию игры:
</p>
<pre class="code lua"><span class="co1">-- $Version: 0.5$</span></pre>

<p>
И указать авторство:
</p>
<pre class="code lua"><span class="co1">-- $Author: Анонимный любитель текстовых приключений$</span></pre>

<p>
Если вы разрабатываете игру в Windows, то убедитесь, что ваш редактор поддерживает кодировку UTF-8 без BOM. Именно эту кодировку следует использовать при написании игры!
</p>

<p>
Сразу после заголовков вам необходимо указать версию STEAD <abbr title="Application Programming Interface">API</abbr>, которая требуется игре. На данный момент последняя версия <strong>1.8.2</strong>.
</p>
<pre class="code lua">instead_version <span class="st0">&quot;1.8.2&quot;</span></pre>
<div class="wrap_center wrap_round wrap_important plugin_wrap">
<p>
<em class="u">Важно!</em>
</p>

<p>
Если instead_version отсутствует, то STEAD <abbr title="Application Programming Interface">API</abbr> будет работать в режиме совместимости (устаревшее <abbr title="Application Programming Interface">API</abbr>). 
</p>
</div>
<p>
Дело в том, что начиная с версии 1.2.0, в INSTEAD для автора появились новые возможности. При этом в
движок была заложена идея постепенного развития <abbr title="Application Programming Interface">API</abbr>.
</p>

<p>
Как это работает?
</p>

<p>
Если вы пишете в начале игры: 
</p>
<pre class="code lua">instead_version <span class="st0">&quot;версия api&quot;</span></pre>

<p>
То вы даете знать движку, что ваш код написан для INSTEAD &gt;= 1.2.0
и при этом вам доступна та версия <abbr title="Application Programming Interface">API</abbr>, которую вы вписали. Например:
</p>
<pre class="code lua">instead_version <span class="st0">&quot;1.8.1&quot;</span></pre>

<p>
Сейчас версии <abbr title="Application Programming Interface">API</abbr> совпадают с версиями INSTEAD.
</p>

<p>
Но есть уже много игр, написанных до версии INSTEAD 1.2.0, и они работают на новых версиях INSTEAD. В этих играх нет instead_version и движок понимает, что игра написана для старой версии <abbr title="Application Programming Interface">API</abbr>.
</p>

<p>
Новое <abbr title="Application Programming Interface">API</abbr> дает множество преимуществ автору (снапшоты, глобальные переменные, изменяемые на лету функции, автоматическое форматирование, модули и пр..), а перенос старого кода на новое <abbr title="Application Programming Interface">API</abbr> тривиален. Поэтому нет большого смысла писать новые игры на старом <abbr title="Application Programming Interface">API</abbr>, что распространено из-за того, что для изучения INSTEAD были выбраны старые игры.
</p>
<div class="wrap_center wrap_round wrap_important plugin_wrap">
<p>
<em class="u">Важно!</em>
</p>

<p>
Поэтому, не изучайте код игр прежде чтения этого руководства!
</p>
</div>
<p>
Далее, обычно следует указать модули, которые требуются игре. О модулях будет рассказано отдельно.
</p>
<pre class="code lua"><span class="kw3">require</span> <span class="st0">&quot;para&quot;</span> <span class="co1">-- красивые отступы;</span>
<span class="kw3">require</span> <span class="st0">&quot;dash&quot;</span> <span class="co1">-- замена символов два минуса на тире;</span>
<span class="kw3">require</span> <span class="st0">&quot;quotes&quot;</span> <span class="co1">-- замена простых кавычек &quot;&quot; на типографские «»;</span></pre>

<p>
Кроме того, обычно стоит определить обработчики по-умолчанию: game.act, game.use, game.inv, о которых также будет рассказано ниже. 
</p>
<pre class="code lua">game<span class="sy0">.</span>act <span class="sy0">=</span> <span class="st0">'Не работает.'</span><span class="sy0">;</span>
game<span class="sy0">.</span>use <span class="sy0">=</span> <span class="st0">'Это не поможет.'</span><span class="sy0">;</span>
game<span class="sy0">.</span>inv <span class="sy0">=</span> <span class="st0">'Зачем мне это?'</span><span class="sy0">;</span></pre>

<p>
<em>Инициализацию</em> игры следует описывать в функции <code>init</code>, которая вызывается движком в самом начале. 
В этой функции удобно инициализировать состояние игрока на начало игры, или какие-то другие действия, нужные для первоначальной настройки мира игры. Впрочем, функция <code>init</code> может быть и не нужна.
</p>
<pre class="code lua"><span class="kw1">function</span> init<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="co1">-- добавим в инвентарь нож и бумагу</span>
    take<span class="br0">&#40;</span>knife<span class="br0">&#41;</span><span class="sy0">;</span>
    take<span class="br0">&#40;</span>paper<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="kw1">end</span></pre>

<p>
Графический интерпретатор ищет доступные игры в каталоге <code>games</code>. Unix-версия интерпретатора кроме этого каталога просматривает также игры в каталоге <code>~/.instead/games</code>.
Windows-версия: <code>Documents and Settings/USER/Local Settings/Application Data/instead/games</code>.
В Windows- и standalone-Unix-версии игры ищутся в каталоге <code>./appdata/games, если он существует</code>.
</p>

<p>
В некоторых сборках INSTEAD (в Windows, в Linux если проект собран с gtk и др.) можно открывать игру по любому пути из меню «Выбор игры». Либо, нажать f4. Если в каталоге с играми присутствует только одна игра, INSTEAD запустит ее автоматически, это удобно, если вы хотите распространять свою игру вместе с движком.
</p>

<p>
Таким образом, вы кладете игру в свой каталог и запускаете INSTEAD. 
</p>
<div class="wrap_center wrap_round wrap_important plugin_wrap">
<p>
<em class="u">Важно!</em>
</p>

<p>
При написании игры, настоятельно рекомендуется использовать отступы для оформления кода игры, как это сделано в примере из данного руководства, этим самым вы сократите количество ошибок и сделаете свой код наглядней!
</p>
</div>
<p>
Ниже приводится минимальный шаблон для вашей первой игры:
</p>
<pre class="code lua"><span class="co1">-- $Name: Моя первая игра$</span>
<span class="co1">-- $Version: 0.1$</span>
<span class="co1">-- $Author: Анонимный автор$</span>
&nbsp;
instead_version <span class="st0">&quot;1.8.2&quot;</span>
&nbsp;
<span class="kw3">require</span> <span class="st0">&quot;para&quot;</span> <span class="co1">-- для оформления</span>
<span class="kw3">require</span> <span class="st0">&quot;dash&quot;</span>
<span class="kw3">require</span> <span class="st0">&quot;quotes&quot;</span>
&nbsp;
<span class="kw3">require</span> <span class="st0">&quot;dbg&quot;</span> <span class="co1">-- для отладки</span>
&nbsp;
game<span class="sy0">.</span>act <span class="sy0">=</span> <span class="st0">'Гм...'</span><span class="sy0">;</span>
game<span class="sy0">.</span>use <span class="sy0">=</span> <span class="st0">'Не сработает.'</span><span class="sy0">;</span>
game<span class="sy0">.</span>inv <span class="sy0">=</span> <span class="st0">'Зачем это мне?'</span><span class="sy0">;</span>
&nbsp;
<span class="kw1">function</span> init<span class="br0">&#40;</span><span class="br0">&#41;</span> 
<span class="co1">-- инициализация, если она нужна</span>
<span class="kw1">end</span></pre>

</div>
<!-- EDIT4 SECTION "Как создавать игру" [9490-17206] -->
<h2 class="sectionedit5" id="основы_отладки">Основы отладки</h2>
<div class="level2">

<p>
Во время отладки (проверки работоспособности вашей игры) удобно, чтобы INSTEAD был запущен с параметром -debug, тогда в случае ошибок будет показана более подробная информация о проблеме в виде стека вызовов. Параметр -debug можно задать в ярлыке (если вы работаете в Windows), а для других систем, я думаю вы и так знаете как передавать параметры командной строки. 
</p>

<p>
При отладке игры обычно нужно часто сохранять игру и загружать состояние игры. Вы можете использовать стандартный механизм сохранений через меню (или по клавишам f2/f3), или воспользоваться быстрым сохранением/загрузкой (клавиши f8/f9).
</p>

<p>
В режиме <code>-debug</code> вы можете перезапускать игру клавишами <code>alt-r</code>. В комбинации с f8/f9 это дает возможность быстро посмотреть изменения в игре после ее правки.
</p>

<p>
В режиме <code>-debug</code> Windows-версия INSTEAD создает консольное окно (в Unix версии, если вы запускаете INSTEAD из консоли, вывод будет направлен в нее) в которое будет осуществляться вывод ошибок. Кроме того, используя функцию <code>print()</code> вы сможете порождать свои сообщения с отладочным выводом. Например:
</p>
<pre class="code lua">        act <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="br0">&#41;</span>
                <span class="kw3">print</span> <span class="br0">&#40;</span><span class="st0">&quot;Act is here! &quot;</span><span class="sy0">..</span>stead<span class="sy0">.</span>deref<span class="br0">&#40;</span>s<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
                <span class="sy0">...</span>
        <span class="kw1">end</span><span class="sy0">;</span></pre>

<p>
Не пугайтесь, когда вы прочитаете все руководство и начнете писать свою игру, вы, скорее всего, взглянете на этот пример с большим воодушевлением.
</p>

<p>
Также удобно воспользоваться модулем отладчика, для этого после записи <code>instead_version</code> добавьте:
</p>
<pre class="code lua"><span class="kw3">require</span> <span class="st0">&quot;dbg&quot;</span></pre>

<p>
Отладчик доступен по клавише f7.
</p>

<p>
Во время отладки бывает удобно изучать файлы сохранений, которые содержат состояние переменных игры. Чтобы не искать каждый раз файлы сохранений, создайте каталог saves в директории с вашей игрой (в том каталоге, где содержится main.lua) и игра будет сохраняться в saves. Этот механизм также будет удобен для переноса игры на другие компьютеры.
</p>

<p>
Возможно (особенно, если вы пользуетесь Unix системами) вам понравится идея проверки синтаксиса ваших скриптов через запуск компилятора <code>luac</code>. В Windows это тоже возможно, нужно только установить выполняемые файлы lua для Windows (<a href="http://luabinaries.sourceforge.net" class="urlextern" title="http://luabinaries.sourceforge.net"  rel="nofollow">http://luabinaries.sourceforge.net</a>)/ и воспользоваться luac52.exe.
</p>

</div>
<!-- EDIT5 SECTION "Основы отладки" [17207-20877] -->
<h1 class="sectionedit6" id="сцена">1. Сцена</h1>
<div class="level1">

<p>
<em>Сцена</em> (или комната) – это единица игры, в рамках которой игрок может изучать все объекты сцены и взаимодействовать с ними. Например, сценой может быть комната, в которой находится герой. Или участком леса, доступным для наблюдения.
</p>

<p>
В любой игре должна быть сцена с именем <code>main</code>. Именно с нее начнется и ваша игра!
</p>
<pre class="code lua">main <span class="sy0">=</span> room <span class="br0">&#123;</span>
	nam <span class="sy0">=</span> <span class="st0">&quot;Главная комната&quot;</span><span class="sy0">;</span>
	dsc <span class="sy0">=</span> <span class="co2">[[Вы в большой комнате.]]</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>

<p>
Запись означает создание объекта (так как почти все сущности в INSTEAD это объекты) <code>main</code> типа <code>room</code> (комната). Текстовый идентификатор <code>main</code>, по которому можно обращаться к комнате, будем в дальнейшем называть идентификатором комнаты.
</p>

<p>
У каждого объекта игры есть <em>атрибуты</em> и <em>обработчики событий</em>. В данном примере есть два атрибута: <code>nam</code> и <code>dsc</code>. Атрибуты разделяются разделителем (в данном примере – символом точка с запятой <code>;</code>).
</p>

<p>
Обычно, атрибуты могут быть текстовыми строками, функциями-обработчиками и булевыми значениями.
</p>

<p>
Например, <em>обязательный</em> атрибут <code>nam</code> для сцены это то, что будет заголовком сцены при ее отображении. Имя сцены также используется для ее идентификации при переходах. Вообще, nam это обязательный атрибут любого объекта. Часто вы можете работать с объектом по его имени, а не по идентификатору.
</p>

<p>
Атрибут <code>dsc</code> – это описание статической части сцены, которое выводится один раз при входе в сцену или при явном осмотре сцены. 
</p>
<div class="wrap_center wrap_round wrap_info plugin_wrap">
<p>
Вы можете использовать символ <code>,</code> вместо <code>;</code> для разделения атрибутов. Например:
</p>
<pre class="code lua">main <span class="sy0">=</span> room <span class="br0">&#123;</span>
        nam <span class="sy0">=</span> <span class="st0">'Главная комната'</span><span class="sy0">,</span>
        dsc <span class="sy0">=</span> <span class="st0">'Вы в большой комнате.'</span><span class="sy0">,</span>
<span class="br0">&#125;</span></pre>
</div><div class="wrap_center wrap_round wrap_tip plugin_wrap">
<p>
Как вы помните, INSTEAD спрячет статическое описание сцены, после того, как игрок его прочитает при входе в сцену.
Если для вашего творческого замысла необходимо, чтобы описание статической части сцены выводилось каждый раз, вы можете определить для своей игры параметр <code>forcedsc</code> (в начале игры).
</p>
<pre class="code lua">game<span class="sy0">.</span>forcedsc <span class="sy0">=</span> <span class="kw4">true</span><span class="sy0">;</span></pre>

<p>
Или, аналогично, задать атрибут forcedsc для конкретных сцен.
</p>
<pre class="code lua">main <span class="sy0">=</span> room <span class="br0">&#123;</span>
        forcedsc <span class="sy0">=</span> <span class="kw4">true</span><span class="sy0">;</span>
        nam <span class="sy0">=</span> <span class="st0">'Главная комната'</span><span class="sy0">;</span>
        dsc <span class="sy0">=</span> <span class="co2">[[Вы в большой комнате.]]</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>

<p>
Но лучше всего на данном этапе не использовать эту технику, так как классические игры INSTEAD не используют ее, а движок по-умолчанию оптимизирован именно на стандартное поведение.
</p>
</div>
<p>
В данном примере все атрибуты – строковые. Строка может быть записана в одинарных или двойных кавычках:
</p>
<pre class="code lua">main <span class="sy0">=</span> room <span class="br0">&#123;</span>
        nam <span class="sy0">=</span> <span class="st0">'Главная комната'</span><span class="sy0">;</span>
        dsc <span class="sy0">=</span> <span class="st0">&quot;Вы в большой комнате.&quot;</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>

<p>
Для длинных описаний удобно использовать запись вида:
</p>
<pre class="code lua">dsc <span class="sy0">=</span> <span class="co2">[[ Очень длинное описание... ]]</span><span class="sy0">;</span></pre>

<p>
При этом переводы строк игнорируются. Если вы хотите, чтобы в выводе описания сцены присутствовали абзацы – используйте символ <code>^</code>.
</p>
<pre class="code lua">dsc <span class="sy0">=</span> <span class="co2">[[ Первый абзац. ^^
Второй Абзац.^^
&nbsp;
Третий абзац.^
На новой строке.]]</span><span class="sy0">;</span></pre>

<p>
Я рекомендую всегда использовать [[ и ]] для <code>dsc</code>.
</p>

<p>
На самом деле, имя <code>nam</code> объекта и его отображение (в данном случае то, как сцена будет выглядеть для игрока в виде надписи сверху окна) можно разделять. Для этого существует атрибут <code>disp</code>. Если он не задан, то считается, что отображение равняется имени, но если это не так, то для функций отображения используется <code>disp</code>, например:
</p>
<pre class="code lua">main <span class="sy0">=</span> room <span class="br0">&#123;</span>
        nam <span class="sy0">=</span> <span class="st0">'Начало'</span><span class="sy0">;</span>
        disp <span class="sy0">=</span> <span class="st0">'Моя комната'</span><span class="sy0">;</span>
        dsc <span class="sy0">=</span> <span class="co2">[[Я нахожусь в своей комнате.]]</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>

</div>
<!-- EDIT6 SECTION "1. Сцена" [20878-26600] -->
<h1 class="sectionedit7" id="объекты">2. Объекты</h1>
<div class="level1">

<p>
<em>Объекты</em> – это единицы сцены, с которыми взаимодействует игрок.  
</p>
<pre class="code lua">tabl <span class="sy0">=</span> obj <span class="br0">&#123;</span>
        nam <span class="sy0">=</span> <span class="st0">'стол'</span><span class="sy0">;</span>
        dsc <span class="sy0">=</span> <span class="st0">'В комнате стоит {стол}.'</span><span class="sy0">;</span>
        act <span class="sy0">=</span> <span class="st0">'Гм... Просто стол...'</span><span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre>

<p>
Обязательное имя объекта <code>nam</code> используется при попадании его в инвентарь, а также в текстовом интерпретаторе для адресации объекта. Если у объекта определен <code>disp</code>, то при попадании в инвентарь для его отображения будет использоваться именно этот атрибут. Например:
</p>
<pre class="code lua">tabl <span class="sy0">=</span> obj <span class="br0">&#123;</span>
        nam <span class="sy0">=</span> <span class="st0">'стол'</span><span class="sy0">;</span>
        disp <span class="sy0">=</span> <span class="st0">'угол стола'</span><span class="sy0">;</span>
        dsc <span class="sy0">=</span> <span class="st0">'В комнате стоит {стол}.'</span><span class="sy0">;</span>
        tak <span class="sy0">=</span> <span class="st0">'Я взялся за угол стола'</span><span class="sy0">;</span>
        inv <span class="sy0">=</span> <span class="st0">'Я держусь за угол стола.'</span><span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre>
<div class="wrap_center wrap_round wrap_info plugin_wrap">
<p>
Вы можете скрывать отображение предмета в инвентаре, если <code>disp</code> атрибут будет равен <code>false</code>.
</p>
</div>
<p>
<code>dsc</code> – описание объекта. Оно будет выведено в динамической части сцены. Фигурными скобками отображается фрагмент текста, который будет являться ссылкой в окне INSTEAD. Если объектов в сцене много, то все описания выводятся одно за другим, через пробел,
</p>

<p>
<code>act</code> – это обработчик события, который вызывается при действии пользователя (действие на объект сцены, обычно – клик мышкой по ссылке). Его задача – вывод (возвращение) строки текста, которая станет частью событий сцены, или логического значения (см. раздел 5).
</p>
<div class="wrap_center wrap_round wrap_important plugin_wrap">
<p>
ВНИМАНИЕ: в пространстве имен <em>lua</em> уже существуют некоторые объекты (таблицы), например: <em>table</em>, <em>io</em>, <em>string</em>… Будьте внимательны при создании объекта. Например, в приведенном примере традиционно используется <code>tabl</code>, а не <code>table</code>. Хотя в новых версиях INSTEAD эта проблема практически полностью решена, и в данном примере можно было бы использовать и идентификатор table.
</p>

<p>
В любом случае, вы не можете использовать дескрипторы объектов, совпадающие с именами конструкторов INSTEAD, такими как: obj, game, player, list, room, dlg.
</p>
</div>
</div>
<!-- EDIT7 SECTION "2. Объекты" [26601-29755] -->
<h1 class="sectionedit8" id="добавляем_объекты_в_сцену">3. Добавляем объекты в сцену</h1>
<div class="level1">

<p>
<em>Ссылкой</em> на объект называется текстовая строка, содержащая дескриптор объекта. Например: &#039;tabl&#039; – ссылка на объект с дескриптором <code>tabl</code>.
</p>

<p>
Для того, чтобы поместить в сцену объекты, существует два пути. 
</p>

<p>
Во-первых, при создании комнаты можно определить список <code>obj</code>, состоящий из ссылок на объекты:
</p>
<pre class="code lua">main <span class="sy0">=</span> room <span class="br0">&#123;</span>
	nam <span class="sy0">=</span> <span class="st0">'Главная комната'</span><span class="sy0">;</span>
	dsc <span class="sy0">=</span> <span class="co2">[[Вы в большой комнате.]]</span><span class="sy0">;</span>
	obj <span class="sy0">=</span> <span class="br0">&#123;</span> <span class="st0">'tabl'</span> <span class="br0">&#125;</span><span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre>

<p>
Теперь, при отображении сцены мы увидим объект <em>«стол»</em> в динамической части.
</p>
<div class="wrap_center wrap_round wrap_info plugin_wrap">
<p>
Вы можете использовать дескрипторы объектов (в данном примере, указав tabl без кавычек) но только в том случае, если объект был определен ранее (перед определением комнаты). По этой причине использование кавычек всегда безопасней и рекомендуется как предпочтительное.
</p>
</div>
<p>
Если в комнату помещаются несколько объектов, разделяйте их ссылки запятыми, например:
</p>
<pre class="code lua">	obj <span class="sy0">=</span> <span class="br0">&#123;</span> <span class="st0">'tabl'</span><span class="sy0">,</span> <span class="st0">'apple'</span> <span class="br0">&#125;</span><span class="sy0">;</span></pre>

<p>
Вы можете вставлять переводы строк для наглядности, когда объектов много, например, так:
</p>
<pre class="code lua">	obj <span class="sy0">=</span> <span class="br0">&#123;</span> 
                 <span class="st0">'tabl'</span><span class="sy0">,</span> 
                 <span class="st0">'apple'</span><span class="sy0">,</span>
                 <span class="st0">'knofe'</span><span class="sy0">,</span> 
        <span class="br0">&#125;</span><span class="sy0">;</span></pre>

<p>
Второй способ размещения предметов заключается в вызове функций, которые поместят объекты в требуемые комнаты. Он будет рассмотрен в дальнейшем.
</p>

</div>
<!-- EDIT8 SECTION "3. Добавляем объекты в сцену" [29756-31922] -->
<h1 class="sectionedit9" id="объекты_связанные_с_другими_объектами">4. Объекты, связанные с другими объектами</h1>
<div class="level1">

<p>
Объекты тоже могут содержать атрибут <code>obj</code>. При этом, при выводе объектов, INSTEAD будет разворачивать списки последовательно. Такая техника может использоваться для создания объектов-контейнеров или просто для связывания нескольких описаний вместе. Например, поместим на стол <em>яблоко</em>.
</p>
<pre class="code lua">apple <span class="sy0">=</span> obj <span class="br0">&#123;</span>
	nam <span class="sy0">=</span> <span class="st0">'яблоко'</span><span class="sy0">;</span>
	dsc <span class="sy0">=</span> <span class="co2">[[На столе лежит {яблоко}.]]</span><span class="sy0">;</span>
	act <span class="sy0">=</span> <span class="st0">'Взять что-ли?'</span><span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span>
&nbsp;
tabl <span class="sy0">=</span> obj <span class="br0">&#123;</span>
	nam <span class="sy0">=</span> <span class="st0">'стол'</span><span class="sy0">;</span>
	dsc <span class="sy0">=</span> <span class="co2">[[В комнате стоит {стол}.]]</span><span class="sy0">;</span>
	act <span class="sy0">=</span> <span class="st0">'Гм... Просто стол...'</span><span class="sy0">;</span>
	obj <span class="sy0">=</span> <span class="br0">&#123;</span> <span class="st0">'apple'</span> <span class="br0">&#125;</span><span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre>

<p>
При этом, в описании сцены мы увидим описание объектов <em>стол</em> и <em>яблоко</em>, так как <code>apple</code> – связанный с <code>tabl</code> объект и движок при выводе объекта <code>tabl</code> вслед за его <code>dsc</code> выведет последовательно <code>dsc</code> всех вложенных в него объектов.
</p>

<p>
Также, следует отметить, что оперируя объектом стол (например, перемещая его из комнаты в комнату) мы автоматически будем перемещать и вложенный в него объект яблоко.
</p>

</div>
<!-- EDIT9 SECTION "4. Объекты, связанные с другими объектами" [31923-33547] -->
<h1 class="sectionedit10" id="атрибуты_и_обработчики_как_функции">5. Атрибуты и обработчики как функции</h1>
<div class="level1">

<p>
Большинство атрибутов и обработчиков могут быть <em>функциями</em>. Так, например:
</p>
<pre class="code lua">nam <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span><span class="br0">&#41;</span>
	p <span class="st0">'яблоко'</span><span class="sy0">;</span>
<span class="kw1">end</span><span class="sy0">;</span></pre>

<p>
Пример не очень удачен, так как проще было бы написать nam = &#039;яблоко&#039;, но показывает синтаксис записи функции.
</p>

<p>
Основная задача такой функции – это возврат <em>строки</em> или булевого значения. Сейчас мы рассматриваем возврат строки. Для возврата строки вы можете использовать явную запись в виде:
</p>
<pre class="code lua">      <span class="kw1">return</span> <span class="st0">&quot;яблоко&quot;</span><span class="sy0">;</span></pre>

<p>
При этом ход выполнения кода функции прекращается и она возвращает движку строку. В данном случае «яблоко».
</p>

<p>
Более привычным способом вывода являются функции:
</p>
<ul>
<li class="level1"><div class="li"> <code>p («текст»)</code> – вывод текста и пробела;</div>
</li>
<li class="level1"><div class="li"> <code>pn («текст»)</code> – вывод текста с переводом строки;</div>
</li>
<li class="level1"><div class="li"> <code>pr («текст»)</code> – вывод текста как есть;</div>
</li>
</ul>
<div class="wrap_center wrap_round wrap_tip plugin_wrap">
<p>
Если <code>p</code>/<code>pn</code>/<code>pr</code> вызывается с одним текстовым параметром, то скобки можно опускать.
</p>
<pre class="code lua">pn <span class="st0">&quot;Нет скобкам!&quot;</span><span class="sy0">;</span></pre>
</div>
<p>
Все эти функции дописывают текст в буфер и при возврате из функции возвращают его движку. Таким образом вы можете постепенно формировать вывод за счет последовательного выполнения <code>p/pn/pr</code>. Имейте в виду, что автору крайне редко необходимо явно форматировать текст, особенно если это описание объектов, движок сам расставляет необходимые переводы строк и пробелы для разделения информации разного рода и делает это унифицированным способом. 
</p>

<p>
Вы можете использовать <code>..</code> или <code>,</code> для склейки строк. Тогда ( и ) обязательны. Например:
</p>
<pre class="code lua">pn <span class="br0">&#40;</span><span class="st0">&quot;Строка 1&quot;</span><span class="sy0">..</span><span class="st0">&quot; Строка 2&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
pn <span class="br0">&#40;</span><span class="st0">&quot;Строка 1&quot;</span><span class="sy0">,</span> <span class="st0">&quot;Строка 2&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Для очистки буфера (если это нужно), используйте <code>pclr()</code>. Если вам нужно получить содержимое текущего буфера – <code>pget()</code>.
</p>
<div class="wrap_center wrap_round wrap_tip plugin_wrap">
<p>
Основное отличие атрибутов от обработчиков событий состоит в том, что обработчики событий могут менять состояние игрового мира, а атрибуты нет. Поэтому, если вы оформляете атрибут (например, <code>nam</code> или <code>dsc</code>) в виде функции, помните, что задача атрибута это возврат значения, а не изменение состояния игры! Дело в том, что движок обращается к атрибутам в те моменты времени, которые обычно четко не определены, и не связаны явно с какими-то игровыми процессами!
</p>
</div><div class="wrap_center wrap_round wrap_important plugin_wrap">
<p>
Еще одной особенностью обработчиков является тот факт, что вы не должны ждать каких то событий внутри обработчика. То есть, не должно быть каких-то циклов ожидания, или организации задержек (пауз). Дело в том, что задача обработчика – изменить игровое состояние и отдать управление INSTEAD, который визуализирует эти изменения и снова перейдет в ожидание действий пользователя. Если вам требуется организовать задержки вывода, вам придется воспользоваться модулем «timer» или «cutscene».
</p>
</div>
<p>
Функции практически всегда содержат условия и работу с переменными. Например:
</p>
<pre class="code lua">apple <span class="sy0">=</span> obj <span class="br0">&#123;</span>
	nam <span class="sy0">=</span> <span class="st0">'яблоко'</span><span class="sy0">;</span>
	dsc <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="br0">&#41;</span>
		<span class="kw1">if</span> <span class="kw2">not</span> s<span class="sy0">.</span>_seen <span class="kw1">then</span>
			p <span class="st0">'На столе {что-то} лежит.'</span><span class="sy0">;</span>
		<span class="kw1">else</span>
			p <span class="st0">'На столе лежит {яблоко}.'</span><span class="sy0">;</span>
		<span class="kw1">end</span>
	<span class="kw1">end</span><span class="sy0">;</span>
	act <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="br0">&#41;</span>
		<span class="kw1">if</span> s<span class="sy0">.</span>_seen <span class="kw1">then</span>
			p <span class="st0">'Это яблоко!'</span><span class="sy0">;</span>
		<span class="kw1">else</span>
			s<span class="sy0">.</span>_seen <span class="sy0">=</span> <span class="kw4">true</span><span class="sy0">;</span>
			p <span class="st0">'Гм... Это же яблоко!'</span><span class="sy0">;</span>
		<span class="kw1">end</span>
	<span class="kw1">end</span><span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre>

<p>
Если атрибут или обработчик оформлен как функция, то всегда <em>первый аргумент</em> функции (<code>s</code>) – сам объект. То есть, в данном примере, <code>s</code> это синоним <code>apple</code>. Когда вы работаете с самим объектом в функции, удобнее использовать параметр, а не дескриптор, так как при переименовании дескриптора вам не придется переписывать вашу игру.
</p>

<p>
В данном примере при показе сцены в динамической части сцены будет выведен текст: &#039;На столе что-то лежит&#039;. При взаимодействии с &#039;что-то&#039;, переменная <code>_seen</code> объекта <code>apple</code> будет установлена в <code>true</code> – истина, и мы увидим, что это было яблоко.
</p>

<p>
Как видим, синтаксис оператора <code>if</code> довольно очевиден. Для наглядности, несколько примеров.
</p>

<p>
if &lt;выражение&gt; then &lt;действия&gt; end
</p>
<pre class="code lua"><span class="kw1">if</span> have <span class="br0">&#40;</span>apple<span class="br0">&#41;</span> <span class="kw1">then</span>
    p <span class="st0">'У меня есть яблоко!'</span>
<span class="kw1">end</span></pre>

<p>
if &lt;выражение&gt; then &lt;действия&gt; else &lt;действия иначе&gt; end
</p>
<pre class="code lua"><span class="kw1">if</span> have <span class="br0">&#40;</span>apple<span class="br0">&#41;</span> <span class="kw1">then</span>
    p <span class="st0">'У меня есть яблоко!'</span>
<span class="kw1">else</span>
    p <span class="st0">'У меня нет яблока!'</span>
<span class="kw1">end</span></pre>

<p>
if &lt;выражение&gt; then &lt;действия&gt; elseif &lt;выражение 2&gt; then &lt;действия 2&gt; else &lt;иначе&gt; end и т.д.
</p>
<pre class="code lua"><span class="kw1">if</span> have <span class="br0">&#40;</span>apple<span class="br0">&#41;</span> <span class="kw1">then</span>
    p <span class="st0">'У меня есть яблоко!'</span>
<span class="kw1">elseif</span> have <span class="br0">&#40;</span>fork<span class="br0">&#41;</span>
    p <span class="st0">'У меня нет яблока, но есть вилка!'</span>
<span class="kw1">else</span>
    p <span class="st0">'У меня нет ни яблока, ни вилки!'</span>
<span class="kw1">end</span></pre>

<p>
Выражение в операторе if может содержать логическое «и» (and), «или» (or), «отрицание» (not) и скобки (, ) для задания приоритетов. Запись вида if &lt;переменная&gt; then означает, что переменная не равна false и определена. Равенство описывается как <code>==</code>, неравенство <code>~=</code>.
</p>
<pre class="code lua"><span class="kw1">if</span> <span class="kw2">not</span> have <span class="br0">&#40;</span>apple<span class="br0">&#41;</span> <span class="kw2">and</span> <span class="kw2">not</span> have<span class="br0">&#40;</span>fork<span class="br0">&#41;</span> <span class="kw1">then</span>
    p <span class="st0">'У меня нет ни яблока, ни вилки!'</span>
<span class="kw1">end</span>
&nbsp;
<span class="sy0">...</span>
<span class="kw1">if</span> w <span class="sy0">~=</span> apple <span class="kw1">then</span>
   p <span class="st0">'Это не яблоко.'</span><span class="sy0">;</span>
<span class="kw1">end</span>
<span class="sy0">...</span>
&nbsp;
<span class="kw1">if</span> <span class="kw3">time</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy0">==</span> <span class="nu0">10</span> <span class="kw1">then</span>
   p <span class="st0">'10 й ход настал!'</span>
<span class="kw1">end</span></pre>
<div class="wrap_center wrap_round wrap_important plugin_wrap">
<p>
<em class="u">Важно</em>
</p>

<p>
В ситуации когда переменная не была определена, но используется в условии, считается, что переменная равна пустоте (<code>nil</code>). Так, проверку на существование переменной можно было бы написать следующим образом:
</p>
<pre class="code lua"><span class="kw1">if</span> z <span class="sy0">==</span> <span class="kw4">nil</span> <span class="kw1">then</span>
        p <span class="st0">&quot;Глобальная переменная z не существует.&quot;</span>
<span class="kw1">end</span></pre>

<p>
В то же время, при анализе несуществующих переменные в условиях, считается, что они дают «ложь». То есть, если z не была определена, то:
</p>
<pre class="code lua"><span class="kw1">if</span> <span class="kw2">not</span> z <span class="kw1">then</span>
       p <span class="st0">&quot;Переменная z или не определена, или равна false.&quot;</span>
<span class="kw1">end</span></pre>

<p>
С другой стороны:
</p>
<pre class="code lua"><span class="kw1">if</span> z <span class="sy0">==</span> <span class="kw4">false</span> <span class="kw1">then</span>
       p <span class="st0">&quot;Переменная z равна false.&quot;</span>
<span class="kw1">end</span></pre>

<p>
Учитывайте это при отладке своей игры, так как если вы описались в имени переменной при задании условия, то условие будет работать (без выдачи ошибки), но игровая логика станет некорректной.
</p>
</div>
<p>
Запись <code>s._seen</code> означает, что переменная <code>_seen</code> размещена в объекте <code>s</code> (то есть <code>apple</code>).  Помните, мы назвали первый параметр функции <code>s</code> (от self), а первый параметр – это дескриптор текущего объекта. <em>Подчеркивание</em> означает, что эта переменная <em>попадет в файл сохранения</em> игры.  Файлы сохранения содержат в себе изменения, которые произошли с игровым миром относительно первоначальной инициализации. 
</p>

<p>
На самом деле, есть два способа определения переменных, попадающих в файл сохранения игры.  Либо вы работаете с переменными, имена которых начинаются с символа <code>_</code>, и тогда вы можете создавать такие переменные на лету, либо вы должны явно определять (инициализировать) переменные с помощью конструкций <code>var</code> и <code>global</code>.
</p>
<pre class="code lua">global <span class="br0">&#123;</span> <span class="co1">-- определение глобальных переменных</span>
    global_var <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> <span class="co1">-- число   </span>
    some_number <span class="sy0">=</span> <span class="nu0">1.2</span><span class="sy0">;</span> <span class="co1">-- число</span>
    some_string <span class="sy0">=</span> <span class="st0">'строка'</span><span class="sy0">;</span>
    know_truth <span class="sy0">=</span> <span class="kw4">false</span><span class="sy0">;</span> <span class="co1">-- булево значение</span>
<span class="br0">&#125;</span>
main <span class="sy0">=</span> room <span class="br0">&#123;</span>
    var <span class="br0">&#123;</span> <span class="co1">-- определение переменных комнаты</span>
        i <span class="sy0">=</span> <span class="st0">&quot;a&quot;</span><span class="sy0">;</span>
        z <span class="sy0">=</span> <span class="st0">&quot;b&quot;</span><span class="sy0">;</span>
    <span class="br0">&#125;</span><span class="sy0">;</span>
    nam <span class="sy0">=</span> <span class="st0">'Моя первая комната'</span><span class="sy0">;</span>
    var <span class="br0">&#123;</span>
        new_var <span class="sy0">=</span> <span class="nu0">3</span><span class="sy0">;</span>
    <span class="br0">&#125;</span><span class="sy0">;</span>
    dsc <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="br0">&#41;</span>
        p <span class="br0">&#40;</span><span class="st0">&quot;i == &quot;</span><span class="sy0">,</span> s<span class="sy0">.</span>i<span class="br0">&#41;</span><span class="sy0">;</span>
        p <span class="br0">&#40;</span><span class="st0">&quot;new_var == &quot;</span><span class="sy0">,</span> s<span class="sy0">.</span>new_var<span class="br0">&#41;</span><span class="sy0">;</span>
        p <span class="br0">&#40;</span><span class="st0">&quot;global_var == &quot;</span><span class="sy0">,</span> global_var<span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="kw1">end</span><span class="sy0">;</span></pre>

<p>
Если вы пользуетесь <code>var</code> или <code>global</code>, обязательно присваивайте переменным первоначальные значения! Вы можете инициализировать переменную значением null, если переменная в дальнейшем должна будет хранить дескриптор объекта, а при инициализации этот объект неизвестен. Другими словами, <code>null</code> – это объект-пустышка.
</p>
<div class="wrap_center wrap_round wrap_important plugin_wrap">
<p>
Итак, переменные записываются в файл сохранения, если они размещены в одном из перечисленных типов объектов: комната, объект, игра, игрок, глобальное пространство, при этом начинаются с символа <code>_</code> или определены с помощью <code>var</code> и <code>global</code>. При разработке пользуйтесь простым правилом: всегда объявляйте переменные в блоках <code>var</code> или <code>global</code>, если они будут меняться. Данный способ наиболее нагляден.
</p>
</div>
<p>
В файл сохранения могут быть записаны переменные следующих типов:
</p>
<ul>
<li class="level1"><div class="li"> строки;</div>
</li>
<li class="level1"><div class="li"> булевы величины;</div>
</li>
<li class="level1"><div class="li"> числовые величины;</div>
</li>
<li class="level1"><div class="li"> дескрипторы объектов;</div>
</li>
<li class="level1"><div class="li"> конструкции <code>code</code>;</div>
</li>
</ul>

<p>
Конструкция <code>code</code> – это другой способ определения функций
</p>
<pre class="code lua">	dsc <span class="sy0">=</span> code <span class="co2">[[
		if not self._seen then
			p 'На столе {что-то} лежит.';
		else
			p 'На столе лежит {яблоко}.';
		end
	]]</span><span class="sy0">,</span></pre>

<p>
Обратите внимание, что текст функции задан в скобках [[ ]], и это значит, что текстовые параметры внутри скобок придется задавать кавычками или апострофами.
</p>

<p>
При вызове code автоматически создаются некоторые переменные. При этом в <code>self</code> записан текущий объект, <code>arg1 … arg9</code> и массив <code>args[]</code> – параметры. 
</p>

<p>
Запись <code>code</code> имеет смысл определять в случае, если функция очень короткая, например:
</p>
<pre class="code lua">    act <span class="sy0">=</span> code <span class="co2">[[ walk(sea) ]]</span><span class="sy0">;</span></pre>

<p>
Либо, если вы хотите переопределять функции на лету (Конструкции <code>code</code> сохраняются, если присвоены сохраняемым переменным).
</p>
<pre class="code lua">    var <span class="br0">&#123;</span> 
       act <span class="sy0">=</span> code <span class="co2">[[ walk(sea) ]]</span><span class="sy0">;</span>
    <span class="br0">&#125;</span><span class="sy0">;</span>
<span class="sy0">...</span>
    s<span class="sy0">.</span>act <span class="sy0">=</span> code <span class="co2">[[ walk(ground) ]]</span><span class="sy0">;</span></pre>

<p>
Правда, обычно это очень плохой стиль программирования игры.
Иногда при написании функции вам могут понадобиться вспомогательные переменные, которые хранят какие-то промежуточные значения, например:
</p>
<pre class="code lua">kitten <span class="sy0">=</span> obj <span class="br0">&#123;</span>
        nam <span class="sy0">=</span> <span class="st0">'котенок'</span><span class="sy0">;</span>
        var <span class="br0">&#123;</span> state <span class="sy0">=</span> <span class="nu0">1</span> <span class="br0">&#125;</span><span class="sy0">;</span>
        act <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="br0">&#41;</span>
                s<span class="sy0">.</span>state <span class="sy0">=</span> s<span class="sy0">.</span>state <span class="sy0">+</span> <span class="nu0">1</span>
                <span class="kw1">if</span> s<span class="sy0">.</span>state <span class="sy0">&gt;</span> <span class="nu0">3</span> <span class="kw1">then</span>
                        s<span class="sy0">.</span>state <span class="sy0">=</span> <span class="nu0">1</span>
                <span class="kw1">end</span>
                p <span class="co2">[[Муррр!]]</span>
        <span class="kw1">end</span><span class="sy0">;</span>
        dsc <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="br0">&#41;</span>
                <span class="kw1">local</span> dsc <span class="sy0">=</span> <span class="br0">&#123;</span>
                        <span class="st0">&quot;{Котенок} мурлычет.&quot;</span><span class="sy0">,</span>
                        <span class="st0">&quot;{Котенок} играет.&quot;</span><span class="sy0">,</span>
                        <span class="st0">&quot;{Котенок} облизывается.&quot;</span><span class="sy0">,</span>
                <span class="br0">&#125;</span><span class="sy0">;</span>
                p<span class="br0">&#40;</span>dsc<span class="br0">&#91;</span>s<span class="sy0">.</span>state<span class="br0">&#93;</span><span class="br0">&#41;</span>
        <span class="kw1">end</span><span class="sy0">;</span>
<span class="kw1">end</span></pre>

<p>
Как видим, в функции dsc мы определили массив dsc. <code>local</code> указывает на то, что он действует в пределах функции dsc. Если вам нужны вспомогательные переменные в функциях, всегда пишите перед их определением <code>local</code>. Конечно, данный пример можно было написать и так:
</p>
<pre class="code lua">dsc <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="br0">&#41;</span>
        <span class="kw1">if</span> s<span class="sy0">.</span>state <span class="sy0">==</span> <span class="nu0">1</span> <span class="kw1">then</span>
                p <span class="st0">&quot;{Котенок} мурлычет.&quot;</span>
        <span class="kw1">elseif</span> s<span class="sy0">.</span>state <span class="sy0">==</span> <span class="nu0">2</span> <span class="kw1">then</span>
                p <span class="st0">&quot;{Котенок} играет.&quot;</span>
        <span class="kw1">else</span>
                p <span class="st0">&quot;{Котенок} облизывается.&quot;</span><span class="sy0">,</span>
        <span class="kw1">end</span></pre>

<p>
Вы можете писать свои вспомогательные функции и использовать их из своей игры, например:
</p>
<pre class="code lua"><span class="kw1">function</span> mprint<span class="br0">&#40;</span>n<span class="sy0">,</span> <span class="sy0">...</span><span class="br0">&#41;</span>
        <span class="kw1">local</span> a <span class="sy0">=</span> <span class="br0">&#123;</span><span class="sy0">...</span><span class="br0">&#125;</span><span class="sy0">;</span> <span class="co1">-- временный массив с аргументами к функции</span>
        p<span class="br0">&#40;</span>a<span class="br0">&#91;</span>n<span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="co1">-- выведем n-й элемент массива</span>
<span class="kw1">end</span>
<span class="sy0">....</span>
        dsc <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="br0">&#41;</span>
                mprint<span class="br0">&#40;</span>s<span class="sy0">.</span>state<span class="sy0">,</span> <span class="br0">&#123;</span>
                        <span class="st0">&quot;{Котенок} мурлычет.&quot;</span><span class="sy0">,</span>
                        <span class="st0">&quot;{Котенок} играет.&quot;</span><span class="sy0">,</span>
                        <span class="st0">&quot;{Котенок} облизывается.&quot;</span> <span class="br0">&#125;</span><span class="br0">&#41;</span><span class="sy0">;</span>
        <span class="kw1">end</span><span class="sy0">;</span></pre>

<p>
Пока не обращайте внимания на данный пример, если он кажется вам сложным.
</p>

<p>
Иногда может понадобиться обработчик, который совершал бы некоторое действие, но не выводил никакого описания. Например:
</p>
<pre class="code lua">button <span class="sy0">=</span> obj <span class="br0">&#123;</span>
	nam <span class="sy0">=</span> <span class="st0">&quot;кнопка&quot;</span><span class="sy0">;</span>
        var <span class="br0">&#123;</span>
                on <span class="sy0">=</span> <span class="kw4">false</span><span class="sy0">;</span>
        <span class="br0">&#125;</span><span class="sy0">;</span>
	dsc <span class="sy0">=</span> <span class="st0">&quot;На стене комнаты видна большая красная {кнопка}.&quot;</span><span class="sy0">;</span>
	act <span class="sy0">=</span> <span class="kw1">function</span> <span class="br0">&#40;</span>s<span class="br0">&#41;</span>
         	s<span class="sy0">.</span>on <span class="sy0">=</span> <span class="kw4">true</span>
                <span class="kw1">return</span> <span class="kw4">true</span>
        <span class="kw1">end</span><span class="sy0">;</span>
<span class="br0">&#125;</span>
&nbsp;
r12 <span class="sy0">=</span> room <span class="br0">&#123;</span>
	nam <span class="sy0">=</span> <span class="st0">'Комната'</span><span class="sy0">;</span>
        forcedsc <span class="sy0">=</span> <span class="kw4">true</span><span class="sy0">;</span>
	dsc <span class="sy0">=</span> <span class="kw1">function</span> <span class="br0">&#40;</span>s<span class="br0">&#41;</span>
                <span class="kw1">if</span> <span class="kw2">not</span> button<span class="sy0">.</span>on <span class="kw1">then</span>
                        p <span class="co2">[[Я нахожусь в комнате.]]</span><span class="sy0">;</span>
                <span class="kw1">else</span>
                        p <span class="co2">[[Я нахожусь в комнате с нажатой кнопкой.]]</span><span class="sy0">;</span>
                <span class="kw1">end</span>
        <span class="kw1">end</span><span class="sy0">,</span>
	obj <span class="sy0">=</span> <span class="br0">&#123;</span><span class="st0">'button'</span><span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre>

<p>
В данном случае обработчик <code>act</code> нужен для того, чтобы поменять описание комнаты, и не нужно, чтобы он выводил результат действия. Если честно, это плохой пример, и его искусственность показывает, что вам вряд ли понадобится делать обработчики без реакции. Действительно, почему бы в приведенном примере не вывести в <code>act</code> что-то вроде: «Я нажал на кнопку»? Кроме того, нам пришлось еще включить режим <code>forcedsc</code>. Тем не менее, необходимость пустой реакции может возникнуть.
</p>

<p>
Для отключения результата можно вернуть из обработчика значение <code>true</code> – это будет означать, что действие успешно выполнено, но не требует дополнительного описания. 
</p>

<p>
Если необходимо показать, что действие невыполнимо, ничего не возвращайте. При этом будет отображено описание по умолчанию, заданное с помощью обработчика <code>game.act</code>. Обычно описание по умолчанию содержит описание невыполнимых действий. Что-то вроде:
</p>
<pre class="code lua">game<span class="sy0">.</span>act <span class="sy0">=</span> <span class="st0">'Гм... Не получается...'</span><span class="sy0">;</span></pre>

<p>
Обратите внимание, что для создания динамического описания сцены в рассмотренном выше примере используется функция <code>dsc</code>. Почему бы не менять значение <code>dsc</code> на лету? На самом деле такой вариант сработает только в том случае, если <code>dsc</code> объявить в блоке <code>var</code>. Например, данный пример мог бы выглядеть так:
</p>
<pre class="code lua">button <span class="sy0">=</span> obj <span class="br0">&#123;</span>
	nam <span class="sy0">=</span> <span class="st0">&quot;кнопка&quot;</span><span class="sy0">;</span>
	dsc <span class="sy0">=</span> <span class="st0">&quot;На стене комнаты видна большая красная {кнопка}.&quot;</span><span class="sy0">;</span>
	act <span class="sy0">=</span> <span class="kw1">function</span> <span class="br0">&#40;</span>s<span class="br0">&#41;</span>
         	here<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">.</span>dsc <span class="sy0">=</span> <span class="co2">[[Теперь комната выглядит совсем по-другому!!!]]</span><span class="sy0">;</span>
	        pn <span class="co2">[[После того как я нажал на кнопку, комната преобразилась. 
		  Книжный шкаф куда-то исчез вместе со столом и комодом, а на его месте 
		  появился странного вида аппарат.]]</span><span class="sy0">;</span>
        <span class="kw1">end</span><span class="sy0">,</span>
<span class="br0">&#125;</span>
&nbsp;
r12 <span class="sy0">=</span> room <span class="br0">&#123;</span>
	nam <span class="sy0">=</span> <span class="st0">'Комната'</span><span class="sy0">;</span>
        var <span class="br0">&#123;</span>
	        dsc <span class="sy0">=</span> <span class="co2">[[Я нахожусь в комнате.]]</span><span class="sy0">;</span>
        <span class="br0">&#125;</span><span class="sy0">;</span>
	obj <span class="sy0">=</span> <span class="br0">&#123;</span><span class="st0">'button'</span><span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre>

<p>
Правда, такой стиль программирования не рекомендуется. Во-первых, вы запутываете код игры, так как тексты описаний перестают быть локализованными в объектах, которые они описывают. Во-вторых, файлы сохранений будут занимать гораздо больший объем. Я советую всегда использовать функции для изменяющихся атрибутов и реакций, а не менять их значение динамически извне.
</p>
<div class="wrap_center wrap_round wrap_info plugin_wrap">
<p>
Иногда возникает необходимость вызвать обработчик вручную. Для этого используется <code>lua</code> синтаксис вызова метода. <code>Объект:метод(параметры)</code>. Например:
</p>
<pre class="code lua">apple<span class="sy0">:</span>act<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="co1">-- вызовем обработчик ''act'' у объекта ''apple''. </span></pre>

<p>
На самом деле, это синоним следующей записи:
</p>
<pre class="code lua">apple<span class="sy0">.</span>act<span class="br0">&#40;</span>apple<span class="br0">&#41;</span> <span class="co1">-- вызовем обработчик ''act'' у объекта ''apple'' </span>
<span class="co1">-- (явно указав 1-й параметр)</span></pre>

<p>
Однако, такой метод работает только в том случае, если вызываемый метод оформлен как функция. Вы можете воспользоваться <code>stead.call()</code> для вызова обработчика тем способом, каким это делает сам INSTEAD. (Будет описано в дальнейшем).
</p>
</div>
</div>
<!-- EDIT10 SECTION "5. Атрибуты и обработчики как функции" [33548-55836] -->
<h1 class="sectionedit11" id="инвентарь">6. Инвентарь</h1>
<div class="level1">

<p>
Простейший вариант сделать объект, который можно брать – определить обработчик <code>tak</code>.
</p>

<p>
Например:
</p>
<pre class="code lua">apple <span class="sy0">=</span> obj <span class="br0">&#123;</span>
        nam <span class="sy0">=</span> <span class="st0">'яблоко'</span><span class="sy0">;</span>
        dsc <span class="sy0">=</span> <span class="st0">'На столе лежит {яблоко}.'</span><span class="sy0">;</span>
        inv <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="br0">&#41;</span>
                <span class="kw3">remove</span><span class="br0">&#40;</span>s<span class="sy0">,</span> me<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span> <span class="co1">-- удалить яблоко из инвентаря</span>
                p <span class="st0">'Я съел яблоко.'</span>
        <span class="kw1">end</span><span class="sy0">;</span>
        tak <span class="sy0">=</span> <span class="st0">'Вы взяли яблоко.'</span><span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre>

<p>
При этом, при действии игрока на объект «яблоко» (щелчок мыши на ссылку в сцене) – яблоко будет убрано из сцены и добавлено в инвентарь. При действии игрока на инвентарь (двойной щелчок мыши на названии объекта) – вызывается обработчик <code>inv</code>.
</p>

<p>
В нашем примере, при действии игроком на яблоко в инвентаре – яблоко будет съедено.
</p>

<p>
Конечно, мы могли бы реализовать код взятия объекта в <code>act</code>, например, так:
</p>
<pre class="code lua">apple <span class="sy0">=</span> obj <span class="br0">&#123;</span>
        nam <span class="sy0">=</span> <span class="st0">'яблоко'</span><span class="sy0">;</span>
        dsc <span class="sy0">=</span> <span class="st0">'На столе лежит {яблоко}.'</span><span class="sy0">;</span>
        inv <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="br0">&#41;</span>
                <span class="kw3">remove</span><span class="br0">&#40;</span>s<span class="sy0">,</span> me<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span> <span class="co1">-- удалить яблоко из инвентаря</span>
                p <span class="st0">'Я съел яблоко.'</span>
        <span class="kw1">end</span><span class="sy0">;</span>
        act <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="br0">&#41;</span>
                take<span class="br0">&#40;</span>s<span class="br0">&#41;</span>
                p <span class="st0">'Вы взяли яблоко.'</span><span class="sy0">;</span>
        <span class="kw1">end</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre>

<p>
Если у объекта в инвентаре не объявлен обработчик <code>inv</code> будет вызван <code>game.inv</code>.
</p>

</div>
<!-- EDIT11 SECTION "6. Инвентарь" [55837-57668] -->
<h1 class="sectionedit12" id="переходы_между_сценами">7. Переходы между сценами</h1>
<div class="level1">

<p>
Традиционные переходы в INSTEAD выглядят как ссылки над описанием сцены. Для определения таких переходов между сценами используется атрибут сцены – список <code>way</code>. В списке определяются комнаты, в виде ссылок на комнаты или дескрипторов комнат (аналогично списку <code>obj</code>). Например:
</p>
<pre class="code lua">room2 <span class="sy0">=</span> room <span class="br0">&#123;</span>
	nam <span class="sy0">=</span> <span class="st0">'Зал'</span><span class="sy0">;</span>
	dsc <span class="sy0">=</span> <span class="st0">'Вы в огромном зале.'</span><span class="sy0">;</span>
	way <span class="sy0">=</span> <span class="br0">&#123;</span> <span class="st0">'main'</span> <span class="br0">&#125;</span><span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span>
&nbsp;
main <span class="sy0">=</span> room <span class="br0">&#123;</span>
	nam <span class="sy0">=</span> <span class="st0">'Главная комната'</span><span class="sy0">;</span>
	dsc <span class="sy0">=</span> <span class="st0">'Вы в большой комнате.'</span><span class="sy0">;</span>
	obj <span class="sy0">=</span> <span class="br0">&#123;</span> <span class="st0">'tabl'</span> <span class="br0">&#125;</span><span class="sy0">;</span>
	way <span class="sy0">=</span> <span class="br0">&#123;</span> <span class="st0">'room2'</span> <span class="br0">&#125;</span><span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre>

<p>
При этом, вы сможете переходить между сценами <code>main</code> и <code>room2</code>. Как вы помните, <code>nam</code> (или <code>disp</code>) может быть функцией, и вы можете генерировать имена сцен на лету, например, если вы хотите, чтобы игрок не знал название сцены, пока не попал на нее. Хотя для этой цели есть более удачные средства, вроде модуля <code>wroom</code>, о котором будет рассказано позже.
</p>

<p>
При переходе между сценами движок вызывает обработчик <code>exit</code> из текущей сцены и <code>enter</code> в той сцене, куда идет игрок. Например:
</p>
<pre class="code lua">room2 <span class="sy0">=</span> room <span class="br0">&#123;</span>
	enter <span class="sy0">=</span> <span class="st0">'Вы заходите в зал.'</span><span class="sy0">;</span>
	nam <span class="sy0">=</span> <span class="st0">'Зал'</span><span class="sy0">;</span>
	dsc <span class="sy0">=</span> <span class="st0">'Вы в огромном зале.'</span><span class="sy0">;</span>
	way <span class="sy0">=</span> <span class="br0">&#123;</span> <span class="st0">'main'</span> <span class="br0">&#125;</span><span class="sy0">;</span>
	<span class="kw3">exit</span> <span class="sy0">=</span> <span class="st0">'Вы выходите из зала.'</span><span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre>

<p>
Конечно, как и все обработчики, <code>exit</code> и <code>enter</code> могут быть функциями. Тогда первый параметр это (как всегда) <em>сам объект</em>, а второй это комната куда игрок <em>хочет идти</em> (для <code>exit</code>) или из которой <em>уходит</em> (для <code>enter</code>). Например:
</p>
<pre class="code lua">room2 <span class="sy0">=</span> room <span class="br0">&#123;</span>
	enter <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="sy0">,</span> f<span class="br0">&#41;</span>
		<span class="kw1">if</span> f <span class="sy0">==</span> main <span class="kw1">then</span>
			p <span class="st0">'Вы пришли из комнаты.'</span><span class="sy0">;</span>
		<span class="kw1">end</span>
	<span class="kw1">end</span><span class="sy0">;</span>
	nam <span class="sy0">=</span> <span class="st0">'Зал'</span><span class="sy0">;</span>
	dsc <span class="sy0">=</span> <span class="st0">'Вы в огромном зале.'</span><span class="sy0">;</span>
	way <span class="sy0">=</span> <span class="br0">&#123;</span> <span class="st0">'main'</span> <span class="br0">&#125;</span><span class="sy0">;</span>
	<span class="kw3">exit</span> <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="sy0">,</span> t<span class="br0">&#41;</span>
		<span class="kw1">if</span> t <span class="sy0">==</span> main <span class="kw1">then</span>
			p <span class="st0">'Я не хочу назад!'</span>
                        <span class="kw1">return</span> <span class="kw4">false</span>
		<span class="kw1">end</span>
	<span class="kw1">end</span><span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre>

<p>
Как видим, эти обработчики могут возвращать два значения: <em>строку</em> и <em>статус</em>. В нашем примере функция <code>exit</code> вернет <code>false</code>, если игрок попытается уйти из зала в комнату <code>main</code>. <code>false</code> означает, что переход <em>не будет</em> выполнен. Такая же логика работает и для <code>enter</code>. Кроме того, она работает и для обработчика <code>tak</code>.
</p>

<p>
Вы можете сделать возврат статуса и другим способом, если это кажется вам удобным: 
</p>
<pre class="code lua">        <span class="kw1">return</span> <span class="st0">&quot;Я не хочу назад&quot;</span><span class="sy0">,</span> <span class="kw4">false</span></pre>

<p>
Если же вы используете функции <code>p</code>/<code>pn</code>/<code>pr</code>, то просто возвращайте статус операции с помощью завершающего <code>return</code>, как показано в примере выше.
</p>
<div class="wrap_center wrap_round wrap_important plugin_wrap">
<p>
Следует отметить, что при вызове обработчика <code>enter</code> указатель на текущую сцену (here()) может быть <strong>еще не изменен</strong>!!! В INSTEAD есть обработчики <code>left</code> (уход из комнаты) и <code>entered</code> (заход в комнату), которые вызываются уже после того, как переход произошел. Эти обработчики рекомендованы к использованию всегда, когда нет необходимости запрещать переход.
</p>
</div>
<p>
Иногда есть необходимость, чтобы название перехода отличалось от названия комнаты, в которую ведет этот переход. Существует несколько способов сделать это. Например, с помощью <code>vroom</code>.
</p>
<pre class="code lua">room2 <span class="sy0">=</span> room <span class="br0">&#123;</span>
	nam <span class="sy0">=</span> <span class="st0">'Зал'</span><span class="sy0">;</span>
	dsc <span class="sy0">=</span> <span class="st0">'Вы в огромном зале.'</span><span class="sy0">;</span>
	way <span class="sy0">=</span> <span class="br0">&#123;</span> vroom<span class="br0">&#40;</span><span class="st0">'В главную комнату'</span><span class="sy0">,</span> <span class="st0">'main'</span><span class="br0">&#41;</span> <span class="br0">&#125;</span><span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span>
&nbsp;
main <span class="sy0">=</span> room <span class="br0">&#123;</span>
	nam <span class="sy0">=</span> <span class="st0">'Главная комната'</span><span class="sy0">;</span>
	dsc <span class="sy0">=</span> <span class="st0">'Вы в большой комнате.'</span><span class="sy0">;</span>
	obj <span class="sy0">=</span> <span class="br0">&#123;</span> <span class="st0">'tabl'</span> <span class="br0">&#125;</span><span class="sy0">;</span>
	way <span class="sy0">=</span> <span class="br0">&#123;</span> vroom<span class="br0">&#40;</span><span class="st0">'В зал'</span><span class="sy0">,</span> <span class="st0">'room2'</span><span class="br0">&#41;</span> <span class="br0">&#125;</span><span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre>

<p>
На самом деле, функция <code>vroom</code> возвращает комнату с именем, который равен первому параметру, и специальной функцией <code>enter</code>, которая перенаправляет игрока в комнату заданную вторым параметром <code>vroom</code>.
</p>

<p>
Таким образом, <code>vroom</code> позволяет именовать переходы удобным способом. Обратите внимание, что в <code>room2</code> вторая комната задана через ссылку, так как на данный момент <code>main</code> еще не объявлена. Во второй комнате переход также описан в виде ссылки, для общности, хотя в этот момент комната <code>room2</code> уже объявлена, и мы можем убрать апострофы вокруг <code>room2</code> во втором параметре <code>vroom</code>.
</p>

<p>
Если вам не хватает возможностей <code>vroom</code>, вы можете воспользоваться модулем <code>wroom</code>.
</p>

<p>
Иногда вам может потребоваться включать и выключать переходы. На самом деле это требуется не часто. Идея переходов состоит в том, что переход виден даже тогда, когда он невозможен. Например, представим себе сцену перед домом у входной двери. Войти в дом нельзя, так как дверь закрыта.
</p>

<p>
Нет никакого смысла прятать переход «дверь». Просто в функции <code>enter</code> сцены внутри дома мы проверяем, а есть ли у героя ключ? И если ключа нет, говорим о том, что дверь закрыта и запрещаем переход. Это повышает интерактивность и упрощает код. Если же вы хотите сделать дверь объектом сцены, поместите ее в комнату, но в <code>act</code> обработчике сделайте осмотр двери, или дайте возможность игроку открыть ее ключом (как это сделать - мы рассмотрим позже), но сам переход дайте сделать игроку привычным способом через строку переходов.
</p>

<p>
Тем не менее, бывают ситуации, когда переход не очевиден и он появляется в результате каких-то событий. Например, мы осмотрели часы и увидели там секретный лаз.
</p>
<pre class="code lua"><span class="kw3">clock</span> <span class="sy0">=</span> obj <span class="br0">&#123;</span>
        nam <span class="sy0">=</span> <span class="st0">'часы'</span><span class="sy0">;</span>
        dsc <span class="sy0">=</span> <span class="co2">[[Тут есть старинные {часы}.]]</span><span class="sy0">;</span>
        act <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="br0">&#41;</span>
                path<span class="br0">&#40;</span><span class="st0">'В часы'</span><span class="br0">&#41;</span><span class="sy0">:</span>enable<span class="br0">&#40;</span><span class="br0">&#41;</span>
                p <span class="co2">[[Вы видите, что в часах есть потайной ход!]]</span><span class="sy0">;</span>
        <span class="kw1">end</span><span class="sy0">;</span>
<span class="br0">&#125;</span>
hall <span class="sy0">=</span> room <span class="br0">&#123;</span>
	nam <span class="sy0">=</span> <span class="st0">'Зал'</span><span class="sy0">;</span>
	dsc <span class="sy0">=</span> <span class="st0">'Вы в огромном зале.'</span><span class="sy0">;</span>
        obj <span class="sy0">=</span> <span class="br0">&#123;</span> <span class="st0">'clock'</span> <span class="br0">&#125;</span><span class="sy0">;</span>
	way <span class="sy0">=</span> <span class="br0">&#123;</span> vroom<span class="br0">&#40;</span><span class="st0">'В часы'</span><span class="sy0">,</span> <span class="st0">'inclock'</span><span class="br0">&#41;</span><span class="sy0">:</span>disable<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#125;</span><span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre>

<p>
В данном примере, мы создали <em>отключенный</em> переход, за счет вызова метода <code>disable</code> у комнаты созданной с помощью <code>vroom</code>. Метод <code>disable</code> есть у всех объектов, он переводит объект в отключенное состояние, которое означает, что объект перестает рассматриваться движком как существующий. Кроме того, этот метод снова возвращает объект (уже в выключенном состоянии). Замечательным свойством отключенного объекта является то, что его можно <em>включить</em> с помощью метода <code>:enable()</code>;
</p>

<p>
Кстати, если вам удобнее, вы можете использовать более привычную запись функций:
</p>
<pre class="code lua">way <span class="sy0">=</span> <span class="br0">&#123;</span> disable<span class="br0">&#40;</span>vroom<span class="br0">&#40;</span><span class="st0">'В часы'</span><span class="sy0">,</span> <span class="st0">'inclock'</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#125;</span><span class="sy0">;</span></pre>

<p>
Далее, когда игрок нажимает на ссылку, описывающую часы, вызывается обработчик <code>act</code>, который с помощью функции <code>path()</code> находит в <code>way</code> текущей комнаты переход &#039;В часы&#039; и вызывает для него метод <code>enable()</code>. Альтернативный вариант записи, если он кажется вам удобней:
</p>
<pre class="code lua">        act <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="br0">&#41;</span>
                enable<span class="br0">&#40;</span>path<span class="br0">&#40;</span><span class="st0">'В часы'</span><span class="br0">&#41;</span><span class="br0">&#41;</span> 
                <span class="co1">-- вы можете опускать () если у функции 1 параметр, </span>
                <span class="co1">-- таким образом запись enable( path 'В часы' ) </span>
                <span class="co1">-- тоже будет корректной (и более простой)</span>
                p <span class="co2">[[Вы видите, что в часах есть потайной ход!]]</span><span class="sy0">;</span>
        <span class="kw1">end</span><span class="sy0">;</span></pre>

<p>
Если бы нам было необходимо проделать такую процедуру с другой комнатой, то мы бы указали второй параметр при вызове <code>path</code>. Например:
</p>
<pre class="code lua">        path<span class="br0">&#40;</span><span class="st0">'В часы'</span><span class="sy0">,</span> room312<span class="br0">&#41;</span><span class="sy0">:</span>enable<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Если вам не нравится, что в вашей игре есть привязка к имени перехода &#039;В часы&#039;, то вы можете использовать переменные:
</p>
<pre class="code lua">path_clock <span class="sy0">=</span> vroom<span class="br0">&#40;</span><span class="st0">'В часы'</span><span class="sy0">,</span> <span class="st0">'inclock'</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
<span class="kw3">clock</span> <span class="sy0">=</span> obj <span class="br0">&#123;</span>
        nam <span class="sy0">=</span> <span class="st0">'часы'</span><span class="sy0">;</span>
        dsc <span class="sy0">=</span> <span class="co2">[[Тут есть старинные {часы}.]]</span><span class="sy0">;</span>
        act <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="br0">&#41;</span>
                path_clock<span class="sy0">:</span>enable<span class="br0">&#40;</span><span class="br0">&#41;</span>
                p <span class="co2">[[Вы видите, что в часах есть потайной ход!]]</span><span class="sy0">;</span>
        <span class="kw1">end</span><span class="sy0">;</span>
<span class="br0">&#125;</span>
hall <span class="sy0">=</span> room <span class="br0">&#123;</span>
	nam <span class="sy0">=</span> <span class="st0">'Зал'</span><span class="sy0">;</span>
	dsc <span class="sy0">=</span> <span class="st0">'Вы в огромном зале.'</span><span class="sy0">;</span>
        obj <span class="sy0">=</span> <span class="br0">&#123;</span> <span class="st0">'clock'</span> <span class="br0">&#125;</span><span class="sy0">;</span>
	way <span class="sy0">=</span> <span class="br0">&#123;</span> path_clock<span class="sy0">:</span>disable<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#125;</span><span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre>

<p>
Если вы не используете <code>vroom</code>, вы можете включать и выключать сами комнаты:
</p>
<pre class="code lua">inclock <span class="sy0">=</span> room <span class="br0">&#123;</span>
        nam <span class="sy0">=</span> <span class="st0">'Внутри'</span><span class="sy0">;</span>
        dsc <span class="sy0">=</span> <span class="co2">[[Тут темно.]]</span><span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">:</span>disable<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="co1">-- вместо приписки :disable() можно написать</span>
<span class="co1">-- inclock:disable()</span>
<span class="co1">-- или disable(inclock)</span>
&nbsp;
<span class="kw3">clock</span> <span class="sy0">=</span> obj <span class="br0">&#123;</span>
        nam <span class="sy0">=</span> <span class="st0">'часы'</span><span class="sy0">;</span>
        dsc <span class="sy0">=</span> <span class="co2">[[Тут есть старинные {часы}.]]</span><span class="sy0">;</span>
        act <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="br0">&#41;</span>
                inclock<span class="sy0">:</span>enable<span class="br0">&#40;</span><span class="br0">&#41;</span>
                p <span class="co2">[[Вы видите, что в часах есть потайной ход!]]</span><span class="sy0">;</span>
        <span class="kw1">end</span><span class="sy0">;</span>
<span class="br0">&#125;</span>
hall <span class="sy0">=</span> room <span class="br0">&#123;</span>
	nam <span class="sy0">=</span> <span class="st0">'Зал'</span><span class="sy0">;</span>
	dsc <span class="sy0">=</span> <span class="st0">'Вы в огромном зале.'</span><span class="sy0">;</span>
        obj <span class="sy0">=</span> <span class="br0">&#123;</span> <span class="st0">'clock'</span> <span class="br0">&#125;</span><span class="sy0">;</span>
	way <span class="sy0">=</span> <span class="br0">&#123;</span> <span class="st0">'inclock'</span> <span class="br0">&#125;</span><span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre>

<p>
На самом деле, данными вещами не стоит злоупотреблять. Простые игры могут вполне обходиться обычными переходами в виде списка комнат.
</p>

</div>
<!-- EDIT12 SECTION "7. Переходы между сценами" [57669-70109] -->
<h1 class="sectionedit13" id="действие_объектов_друг_на_друга">8. Действие объектов друг на друга</h1>
<div class="level1">

<p>
Игрок может действовать объектом инвентаря на другие объекты. Для этого он щелкает мышью на предмет инвентаря, а затем, на предмет сцены. При этом вызывается обработчик <code>use</code> у объекта, которым действуют, и <code>used</code> – на который действуют. 
</p>

<p>
Например:
</p>
<pre class="code lua">knife <span class="sy0">=</span> obj <span class="br0">&#123;</span>
	nam <span class="sy0">=</span> <span class="st0">'нож'</span><span class="sy0">;</span>
	dsc <span class="sy0">=</span> <span class="st0">'На столе лежит {нож}'</span><span class="sy0">;</span>
	inv <span class="sy0">=</span> <span class="st0">'Острый!'</span><span class="sy0">;</span>
	tak <span class="sy0">=</span> <span class="st0">'Я взял нож!'</span><span class="sy0">;</span>
	use <span class="sy0">=</span> <span class="st0">'Вы пытаетесь использовать нож.'</span><span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span>
&nbsp;
tabl <span class="sy0">=</span> obj <span class="br0">&#123;</span>
	nam <span class="sy0">=</span> <span class="st0">'стол'</span><span class="sy0">;</span>
	dsc <span class="sy0">=</span> <span class="st0">'В комнате стоит {стол}.'</span><span class="sy0">;</span>
	act <span class="sy0">=</span> <span class="st0">'Гм... Просто стол...'</span><span class="sy0">;</span>
	obj <span class="sy0">=</span> <span class="br0">&#123;</span> <span class="st0">'apple'</span><span class="sy0">,</span> <span class="st0">'knife'</span> <span class="br0">&#125;</span><span class="sy0">;</span>
	used <span class="sy0">=</span> <span class="st0">'Вы пытаетесь сделать что-то со столом...'</span><span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre>

<p>
Если игрок возьмет нож и использует его на стол – то он увидит текст обработчиков <code>use</code> (у объекта <code>knife</code>) и <code>used</code> (у объекта <code>tabl</code>). <code>use</code> и <code>used</code>, очевидно, могут быть функциями. 
</p>

<p>
Тогда, в случае функции <code>use</code>, первый параметр к функции – сам объект, которым осуществляется действие, а второй параметр – объект, на который направлено действие. В случае функции <code>used</code>, первый параметр – сам объект, на который производится действие, а второй параметр – объект, которым осуществляется действие.
</p>

<p>
То есть, <em>первый</em> параметр это как всегда <em>сам объект</em>, а <em>второй</em> – объект на который <em>направлено действие</em> в случае <code>use</code> и объект, которым действие <em>осуществляется</em> в случае <code>used</code>. 
</p>

<p>
<code>use</code> может вернуть статус <code>false</code>, в этом случае обработчик <code>used</code> не вызовется (если он вообще был). Статус обработчика <code>used</code> <strong>игнорируется</strong>.
</p>

<p>
Пример:
</p>
<pre class="code lua">knife <span class="sy0">=</span> obj <span class="br0">&#123;</span>
	nam <span class="sy0">=</span> <span class="st0">'нож'</span><span class="sy0">;</span>
	dsc <span class="sy0">=</span> <span class="st0">'На столе лежит {нож}'</span><span class="sy0">;</span>
	inv <span class="sy0">=</span> <span class="st0">'Острый!'</span><span class="sy0">;</span>
	tak <span class="sy0">=</span> <span class="st0">'Я взял нож!'</span><span class="sy0">;</span>
	use <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="sy0">,</span> w<span class="br0">&#41;</span>
		<span class="kw1">if</span> w <span class="sy0">~=</span> tabl <span class="kw1">then</span>
			p <span class="st0">'Не хочу это резать.'</span>
                        <span class="kw1">return</span> <span class="kw4">false</span>
		<span class="kw1">else</span>
			p <span class="st0">'Вы вырезаете на столе свои инициалы.'</span>
		<span class="kw1">end</span>
	<span class="kw1">end</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre>

<p>
В примере выше нож можно использовать только на стол.
</p>

<p>
Если и <code>use</code> и <code>used</code> ничего не вернут (или их нет), вызовется обработчик по-умолчанию <code>game.use</code>.
</p>

<p>
Использовать <code>use</code> или <code>used</code> это вопрос личных предпочтений, однако, всегда следует стараться локализовать код рядом с объектом, к которому он относится. Например, если сделать объект «мусорка» и дать возможность игроку выбрасывать в нее все предметы, то очевидным решением здесь будет обработчик <code>used</code> у мусорки.
</p>
<pre class="code lua">trash <span class="sy0">=</span> obj <span class="br0">&#123;</span>
        nam <span class="sy0">=</span> <span class="st0">'мусорка'</span><span class="sy0">;</span>
        dsc <span class="sy0">=</span> <span class="co2">[[Я вижу {мусорку}.]]</span><span class="sy0">;</span>
        act <span class="sy0">=</span> <span class="st0">'Не полезу я туда.'</span><span class="sy0">;</span>
        used <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="sy0">,</span> w<span class="br0">&#41;</span>
                <span class="kw3">remove</span><span class="br0">&#40;</span>w<span class="sy0">,</span> me<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>
                p <span class="co2">[[Мне это не нужно больше.]]</span><span class="sy0">;</span>
        <span class="kw1">end</span>
<span class="br0">&#125;</span></pre>

<p>
При одновременном использовании <code>use</code> и <code>used</code> могут быть проблемы. Например, пусть у игрока есть нож, при использовании которого на все предметы, кроме яблока, выдается сообщение «Я не хочу это резать.».
</p>

<p>
При применении ножа на мусорку, игроку будет выдано «Я не хочу это резать.», а потом нож навсегда сгинет в ее недрах (так мы написали обработчик <code>used</code>); Конечно, в <code>use</code> ножа можно написать:
</p>
<pre class="code lua">p <span class="st0">&quot;Я не хочу это резать.&quot;</span>
<span class="kw1">return</span> <span class="kw4">false</span> <span class="co1">-- прервать цепочку (не вызывать used)</span></pre>

<p>
Но это не очень удобно. Для решения этой проблемы можно воспользоваться модулем <code>nouse</code>. 
</p>
<pre class="code lua"><span class="sy0">...</span>
<span class="kw3">require</span> <span class="st0">&quot;nouse&quot;</span>
&nbsp;
<span class="sy0">...</span>
knife <span class="sy0">=</span> obj <span class="br0">&#123;</span>
	nam <span class="sy0">=</span> <span class="st0">'нож'</span><span class="sy0">,</span>
	use <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="sy0">,</span> w<span class="br0">&#41;</span>
                <span class="kw1">if</span> w <span class="sy0">~=</span> apple <span class="kw1">then</span> <span class="co1">-- неравенство</span>
                        <span class="kw1">return</span>
                <span class="kw1">end</span>
                <span class="kw1">if</span> w<span class="sy0">.</span>knife <span class="kw1">then</span>
                        <span class="kw1">return</span> <span class="st0">&quot;Я уже почистил его.&quot;</span>
                <span class="kw1">end</span>
                w<span class="sy0">.</span>knife <span class="sy0">=</span> <span class="kw4">true</span>
	        p <span class="st0">'Я почистил яблоко.'</span>
	<span class="kw1">end</span><span class="sy0">;</span>
        nouse <span class="sy0">=</span> <span class="co2">[[Не хочу это резать.]]</span><span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre>

<p>
Обработчик <code>nouse</code> объекта вызывается в том случае, если ни <code>use</code> ни <code>used</code> не вернули реакции. Если и <code>nouse</code> объекта не содержит реакции, то вызовется <code>noused</code> страдательного объекта. Если и в таком случае реакция не прописана, вызовется <code>game.nouse</code>;
</p>

<p>
Конечно, все обработчики могут быть функциями с тремя параметрами. Сам объект (или объект <code>game</code> в случае <code>game.nouse</code>), объект которым действуем и страдательный объект.
</p>
<div class="wrap_center wrap_round wrap_important plugin_wrap">
<p>
Модуль «nouse» переопределяет функцию <code>game.use</code>, поэтому используйте <code>game.nouse</code> если вы включаете модуль &#039;nouse&#039; в свою игру.
</p>
</div>
<p>
Я рекомендую использовать модуль «nouse» всегда, так как код игры становится более наглядным. 
</p>

<p>
На самом деле, в INSTEAD играх можно действовать не только предметом инвентаря на предмет сцены, но и предметом сцены на предмет сцены (и даже предметом сцены на инвентарь). Этот механизм вряд ли действительно стоит использовать, но тем не менее, определив булевый атрибут <code>scene_use</code> в объекте или у игры (<code>game.scene_use</code>), вы можете управлять моментом, когда этот режим доступен.
</p>

<p>
Например: <code>game.scene_use = true</code>. 
</p>

<p>
Атрибут может быть задан функцией, возвращающей булево значение (<code>true</code> или <code>false</code>).
</p>

</div>
<!-- EDIT13 SECTION "8. Действие объектов друг на друга" [70110-77549] -->
<h1 class="sectionedit14" id="объект_player">9. Объект &quot;player&quot;</h1>
<div class="level1">

<p>
Игрок в STEAD представлен объектом <code>pl</code>. Тип объекта – <code>player</code>. В движке объект создается следующим образом:
</p>
<pre class="code lua">pl <span class="sy0">=</span> player <span class="br0">&#123;</span>
        nam <span class="sy0">=</span> <span class="st0">&quot;Incognito&quot;</span><span class="sy0">;</span>
        where <span class="sy0">=</span> <span class="st0">'main'</span><span class="sy0">;</span>
        obj <span class="sy0">=</span> <span class="br0">&#123;</span> <span class="br0">&#125;</span><span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre>

<p>
Атрибут <code>obj</code> представляет собой инвентарь игрока. Обычно, нет смысла переопределять объект типа player, однако, если вы хотите создать переменные, которые бы хранились в игроке, вы можете сделать это:
</p>
<pre class="code lua">pl <span class="sy0">=</span> player <span class="br0">&#123;</span>
        nam <span class="sy0">=</span> <span class="st0">&quot;Василий&quot;</span><span class="sy0">;</span>
        where <span class="sy0">=</span> <span class="st0">'main'</span><span class="sy0">;</span>
        var <span class="br0">&#123;</span> power <span class="sy0">=</span> <span class="nu0">100</span> <span class="br0">&#125;</span><span class="sy0">;</span>
        obj <span class="sy0">=</span> <span class="br0">&#123;</span> <span class="st0">'apple'</span> <span class="br0">&#125;</span><span class="sy0">;</span> <span class="co1">-- заодно добавим яблоко в инвентарь</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre>

<p>
В INSTEAD есть возможность создавать нескольких игроков и переключаться между ними.
Для этого служит функция <code>change_pl()</code>. В качестве параметра передайте функции требуемый объект типа <code>player</code>. Функция переключит текущего игрока, и при необходимости, осуществит переход в комнату, где находится новый игрок.
</p>

<p>
Функция <code>me()</code> всегда возвращает текущего игрока. В большинстве игр <code>me() == pl</code>.
</p>

</div>
<!-- EDIT14 SECTION "9. Объект player" [77550-79146] -->
<h1 class="sectionedit15" id="объект_game">10. Объект &#039;&#039;game&#039;&#039;</h1>
<div class="level1">

<p>
Игра также представлена объектом <code>game</code> с типом <code>game</code>. В движке он определяется следующим образом:
</p>
<pre class="code lua">game <span class="sy0">=</span> game <span class="br0">&#123;</span>
        codepage <span class="sy0">=</span> <span class="st0">&quot;UTF-8&quot;</span><span class="sy0">,</span>
	nam <span class="sy0">=</span> <span class="st0">&quot;INSTEAD -- Simple Text Adventure interpreter v&quot;</span><span class="sy0">..</span>
                       stead<span class="sy0">.</span>version<span class="sy0">..</span><span class="st0">&quot; '2013 by Peter Kosyh&quot;</span><span class="sy0">,</span>
	dsc <span class="sy0">=</span> <span class="co2">[[
Commands:^
    look(or just enter), act &lt;on what&gt; (or just what), use &lt;what&gt; [on what], 
    go &lt;where&gt;,^
    back, inv, way, obj, quit, save &lt;fname&gt;, load &lt;fname&gt;.]]</span><span class="sy0">,</span>
	pl <span class="sy0">=</span><span class="st0">'pl'</span><span class="sy0">,</span>
	showlast <span class="sy0">=</span> <span class="kw4">true</span><span class="sy0">,</span>
        _scripts <span class="sy0">=</span> <span class="br0">&#123;</span><span class="br0">&#125;</span><span class="sy0">,</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre>

<p>
Как видим, объект хранит в себе указатель на текущего игрока (<code>pl</code>) и некоторые параметры. Не существует возможности пересоздать объект <code>game</code>, к счастью, это и не требуется. Однако, вам придется иногда менять некоторые атрибуты.
</p>

<p>
Например, вы можете указать в начале своей игры кодировку текста следующим образом:
</p>
<pre class="code lua">game<span class="sy0">.</span>codepage<span class="sy0">=</span><span class="st0">&quot;cp1251&quot;</span><span class="sy0">;</span> </pre>

<p>
На самом деле, не стоит этого делать. Лучше настройте свой редактор на использование UTF-8. Переопределение кодировки это экстренная мера, например, для игр написанных <code>URQL</code>, которые могут быть запущены в INSTEAD с помощью соответствующего модуля. 
</p>

<p>
Кроме того, объект <code>game</code> может содержать обработчики по умолчанию <code>act</code>, <code>inv</code>, <code>use</code>, которые будут вызваны, если в результате действий пользователя не будут найдены никакие другие обработчики. Например, вы можете написать в начале игры:
</p>
<pre class="code lua">game<span class="sy0">.</span>act <span class="sy0">=</span> <span class="st0">'Не получается.'</span><span class="sy0">;</span>
game<span class="sy0">.</span>inv <span class="sy0">=</span> <span class="st0">'Гм.. Странная штука..'</span><span class="sy0">;</span>
game<span class="sy0">.</span>use <span class="sy0">=</span> <span class="st0">'Не сработает...'</span><span class="sy0">;</span></pre>

<p>
Всегда определяйте эти обработчики в своей игре. В случае, если вы используете модуль «nouse», вместо <code>game.use</code> задавайте <code>game.nouse</code>.
</p>

</div>
<!-- EDIT15 SECTION "10. Объект ''game''" [79147-81638] -->
<h1 class="sectionedit16" id="атрибуты-списки">11. Атрибуты-списки</h1>
<div class="level1">

<p>
Атрибуты-списки (такие как <code>way</code> или <code>obj</code>) позволяют работать со своим содержимым с помощью набора методов. Атрибуты-списки призваны сохранять в себе списки объектов. На самом деле, вы можете создавать списки для собственных нужд, при этом нет необходимости вставлять список в <code>var</code> или <code>global</code>, например:
</p>
<pre class="code lua">treasures <span class="sy0">=</span> list <span class="br0">&#123;</span> <span class="st0">'gold'</span><span class="sy0">,</span> <span class="st0">'silver'</span> <span class="br0">&#125;</span><span class="sy0">;</span></pre>

<p>
Хотя обычно, это не требуется.
</p>

<p>
Методы списков: <code>add</code>, <code>del</code>, <code>look</code>, <code>srch</code>, <code>purge</code>, <code>replace</code>. Из них наиболее часто используемые: <code>add</code> и <code>del</code>.
</p>
<ul>
<li class="level1"><div class="li"> <code>add</code> – добавляет в список объект;</div>
</li>
<li class="level1"><div class="li"> <code>cat</code> – <code>cat(b, [pos])</code> – добавляет в список содержимое списка <code>b</code> в позицию <code>pos</code>;</div>
</li>
<li class="level1"><div class="li"> <code>zap</code> – обнулить список;</div>
</li>
<li class="level1"><div class="li"> <code>del</code> – удаляет объект из списка (если он не выключен);</div>
</li>
<li class="level1"><div class="li"> <code>purge</code> – удаляет даже выключенный объект;</div>
</li>
<li class="level1"><div class="li"> <code>srch</code> – выполняет поиск объекта. Возвращает два значения: элемент списка и индекс (если элемент найден в списке); </div>
</li>
<li class="level1"><div class="li"> <code>replace</code> – замена объекта другим <code>replace(old, new)</code>; </div>
</li>
<li class="level1"><div class="li"> <code>enable</code> – включение объекта (если он найден в списке);</div>
</li>
<li class="level1"><div class="li"> <code>disable</code> – выключение объекта (если он найден в списке);</div>
</li>
<li class="level1"><div class="li"> <code>enable_all</code> – включить все объекты в списке;</div>
</li>
<li class="level1"><div class="li"> <code>disable_all</code> – выключить все объекты в списке;</div>
</li>
</ul>
<div class="wrap_center wrap_round wrap_info plugin_wrap">
<p>
Следует отметить, что параметром <code>add</code>, <code>del</code>, <code>purge</code>, <code>replace</code> и <code>srch</code> и других методов может быть не только сам объект (дескриптор), но и имя объекта (атрибут <code>nam</code>).
</p>
</div>
<p>
Самый часто используемый пример для работы со списками это конструкция вида: <code>inv():del(&#039;apple&#039;)</code>;
</p>

<p>
<code>inv()</code> – это функция, которая возвращает список-инвентарь. <code>del</code> после <code>:</code> – метод, удаляющий элемент инвентаря.
</p>

<p>
Аналогично, собственная реализация <code>tak</code> может быть такой:
</p>
<pre class="code lua">knife <span class="sy0">=</span> obj <span class="br0">&#123;</span>
	nam <span class="sy0">=</span> <span class="st0">'нож'</span><span class="sy0">,</span>
	dsc <span class="sy0">=</span> <span class="st0">'На столе лежит {нож}'</span><span class="sy0">,</span>
	inv <span class="sy0">=</span> <span class="st0">'Острый!'</span><span class="sy0">,</span>
	act <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="br0">&#41;</span>
		objs<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">:</span>del<span class="br0">&#40;</span>s<span class="br0">&#41;</span><span class="sy0">;</span>
		inv<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">:</span>add<span class="br0">&#40;</span>s<span class="br0">&#41;</span><span class="sy0">;</span>
	<span class="kw1">end</span><span class="sy0">,</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre>

<p>
<code>objs()</code> – это функция, которая возвращает список объектов текущей комнаты. Либо любой другой комнаты, если указать ее в качестве параметра к <code>objs()</code>.
</p>

<p>
Для получения списка <code>way</code> используйте функцию <code>ways()</code>.
</p>

<p>
Кроме удаления / добавления объектов из списков вы можете использовать <em>выключение / включение</em> объектов с помощью методов <em>объекта</em> <code>disable()</code> и <code>enable()</code>. Например: <code>knife:disable()</code>. При этом объект <code>knife</code> пропадает из описания сцены (предполагаем, что он находится в списке <code>obj</code> сцены), но в последствии может быть опять быть включен, с помощью <code>knife:enable()</code>. Для проверки того факта, что объект выключен, можно использовать метод <code>:disabled()</code>. Если вам привычней использовать синтаксис функций, вы можете пользоваться записью вида:
</p>
<pre class="code lua">disable<span class="br0">&#40;</span>knife<span class="br0">&#41;</span> <span class="co1">-- или knife:disable()</span>
<span class="sy0">...</span>
<span class="kw1">if</span> <span class="kw2">not</span> disabled<span class="br0">&#40;</span>knife<span class="br0">&#41;</span> <span class="co1">-- или not knife:disabled()</span>
<span class="sy0">...</span></pre>

<p>
Методы <em>списков</em> <code>enable</code> и <code>disable</code> работают аналогично одноименным методам объектов, при условии что искомый объект находится в списке. Например, учитывая, что поиск объекта в списке осуществляется в том числе и по имени, можно написать:
</p>
<pre class="code lua">inv<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">:</span>disable <span class="st0">'нож'</span><span class="sy0">;</span></pre>
<div class="wrap_center wrap_round wrap_important plugin_wrap">
<p>
Внимание!!! Для работы с инвентарем, объектами и переходами рекомендуется использовать более высокоуровневые функции: <code>put</code> / <code>get</code> / <code>take</code> / <code>drop</code> / <code>remove</code> / <code>seen</code> / <code>have</code> и др. функции, которые будут описаны в дальнейшем. Тем не менее, иногда работа со списками оказывается полезной.
</p>
</div>
</div>
<!-- EDIT16 SECTION "11. Атрибуты-списки" [81639-87014] -->
<h1 class="sectionedit17" id="функции_которые_возвращают_объекты">12. Функции, которые возвращают объекты</h1>
<div class="level1">

<p>
В INSTEAD определены некоторые функции, которые возвращают различные объекты или списки.  
При описании функции используются следующие соглашения о параметрах.
</p>
<ul>
<li class="level1"><div class="li"> в символах [ ] описаны необязательные параметры;</div>
</li>
<li class="level1"><div class="li"> <code>что</code> – означает объект (в том числе комнату), заданный дескриптором, ссылкой или именем;</div>
</li>
<li class="level1"><div class="li"> <code>где</code> – означает объект (в том числе комнату), заданный дескриптором или ссылкой;</div>
</li>
<li class="level1"><div class="li"> <code>комната</code> – означает объект типа <code>room</code>, заданный дескриптором или ссылкой;</div>
</li>
<li class="level1"><div class="li"> <code>объект</code> – означает объект типа <code>obj</code>;</div>
</li>
<li class="level1"><div class="li"> <code>переход</code> – означает текстовое имя перехода в <code>way</code>, его дескриптор или ссылку;</div>
</li>
</ul>

<p>
Функции, возвращающие списки:
</p>
<ul>
<li class="level1"><div class="li"> <code>inv()</code> возвращает список инвентаря;</div>
</li>
<li class="level1"><div class="li"> <code>objs([где])</code> возвращает список объектов текущей сцены; Второй необязательный параметр – комната или объект, для которой возвращается список <code>obj</code>;</div>
</li>
<li class="level1"><div class="li"> <code>ways([комната])</code> возвращает список возможных переходов из текущей сцены; Второй необязательный параметр –  комната, для которой возвращается список;</div>
</li>
</ul>

<p>
На самом деле, функции, которые возвращают списки, редко бывают необходимы при написании игры, так как для работы с объектами и переходами существует набор специальных функций, которые описаны в следующей главе.
</p>

<p>
Теперь посмотрим на функции, возвращающие объекты:
</p>
<ul>
<li class="level1"><div class="li"> <code>me()</code> возвращает текущего объекта-игрока;</div>
</li>
<li class="level1"><div class="li"> <code>here()</code> возвращает текущую сцену; </div>
</li>
<li class="level1"><div class="li"> <code>where(объект)</code> возвращает комнату или объект в котором находится заданный объект, если он был помещен туда с помощью функций <code>put/move/drop/replace</code> и т.д.)</div>
</li>
<li class="level1"><div class="li"> <code>from([комната])</code> возвращает прошлую комнату, из которой игрок перешел в текущую комнату. Второй необязательный параметр – получить прошлую комнату не для текущей комнаты, а для заданной;</div>
</li>
<li class="level1"><div class="li"> <code>seen(что, [где])</code> возвращает объект, если он присутствует и не отключен на сцене, есть второй необязательный параметр – выбрать сцену или объект в котором искать <code>что</code>;</div>
</li>
<li class="level1"><div class="li"> <code>have(что)</code> возвращает объект, если он есть в инвентаре и не отключен;</div>
</li>
<li class="level1"><div class="li"> <code>exist(что, [где])</code> возвращает объект, если он присутствует на сцене (даже если он выключен!), есть второй необязательный параметр – выбрать сцену или объект, в котором искать <code>что</code>;</div>
</li>
<li class="level1"><div class="li"> <code>live(что)</code> возвращает объект, если он присутствует среди живых объектов (описано далее);</div>
</li>
<li class="level1"><div class="li"> <code>path(переход, [комната])</code> – найти элемент в <code>way</code>, даже если он выключен. Второй параметр используется, если интересует не текущая, а заданная комната;</div>
</li>
</ul>

<p>
Эти функции в основном используются в условиях, либо для поиска объекта с последующей модификацией.
Например, вы можете использовать <code>seen</code> для написания условия:
</p>
<pre class="code lua"><span class="kw3">exit</span> <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="br0">&#41;</span>
        <span class="kw1">if</span> seen <span class="st0">'монстр'</span> <span class="kw1">then</span> <span class="co1">-- если у функции 1 параметр, </span>
                <span class="co1">--- скобки писать не обязательно</span>
                p <span class="st0">'Монстр загораживает проход!'</span>
                <span class="kw1">return</span> <span class="kw4">false</span>
        <span class="kw1">end</span>
<span class="kw1">end</span></pre>

<p>
А также, для нахождения объекта в сцене:
</p>
<pre class="code lua">use <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="sy0">,</span> w<span class="br0">&#41;</span>
        <span class="kw1">if</span> w <span class="sy0">==</span> window <span class="kw2">and</span> path <span class="st0">'В окно'</span><span class="sy0">:</span>disabled<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="kw1">then</span> 
                <span class="co1">-- действие на окно и нет перехода 'В окно'</span>
                path <span class="st0">'В окно'</span><span class="sy0">:</span>enable<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
                p <span class="st0">'Я разбил окно!'</span>
        <span class="kw1">end</span>
<span class="kw1">end</span></pre>

<p>
Пример с функцией <code>have</code>:
</p>
<pre class="code lua"><span class="sy0">...</span>
act <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="br0">&#41;</span>
	<span class="kw1">if</span> have<span class="br0">&#40;</span><span class="st0">'knife'</span><span class="br0">&#41;</span> <span class="kw1">then</span>
		p <span class="st0">'Но у меня же есть нож!'</span><span class="sy0">;</span>
                <span class="kw1">return</span>
	<span class="kw1">end</span>
<span class="kw1">end</span>
<span class="sy0">...</span></pre>

<p>
Следующие варианты тоже будут работать:
</p>
<pre class="code lua"><span class="sy0">...</span>
	<span class="kw1">if</span> have <span class="st0">'knife'</span> <span class="kw1">then</span>
<span class="sy0">...</span>
	<span class="kw1">if</span> have <span class="br0">&#40;</span>knife<span class="br0">&#41;</span> <span class="kw1">then</span>
<span class="sy0">...</span></pre>

<p>
Еще одна функция, которая получает объект по ссылке:
<code>stead.ref(ссылка)</code>. 
</p>

<p>
На самом деле, вам вряд ли понадобится эта функция, по крайней мере для первой игры. Эта функция получает объект  по ссылке, другими словами:
</p>
<pre class="code lua">stead<span class="sy0">.</span>ref <span class="st0">'apple'</span> <span class="sy0">==</span> apple</pre>

<p>
При условии, конечно, что <code>apple</code> определена.
</p>

<p>
Функция <code>stead.deref(дескриптор)</code>, наоборот, возвращает ссылку-строку для объекта;
</p>
<pre class="code lua">act <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="br0">&#41;</span>
        p<span class="br0">&#40;</span><span class="st0">'Вы кликнули на объект: '</span><span class="sy0">,</span> stead<span class="sy0">.</span>deref<span class="br0">&#40;</span>s<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="kw1">end</span></pre>

</div>
<!-- EDIT17 SECTION "12. Функции, которые возвращают объекты" [87015-93358] -->
<h1 class="sectionedit18" id="другие_функции_instead">13. Другие функции INSTEAD</h1>
<div class="level1">

<p>
В INSTEAD определено множество функций, которые манипулируют состоянием предмета, или используются для написания игровой логики. Многие из них вы уже встречали по мере чтения данного руководства. Теперь рассмотрим их подробней.
</p>
<ul>
<li class="level1"><div class="li"> <code>move(что, куда, [где])</code>  переносит объект из текущей сцены в другую сцену или объект; Если задать параметр <code>где</code>, то объект будет искаться не в текущей сцене, а в сцене или объекте <code>где</code>.</div>
</li>
</ul>
<pre class="code lua">move<span class="br0">&#40;</span><span class="st0">'mycat'</span><span class="sy0">,</span><span class="st0">'inmycar'</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>
<div class="wrap_center wrap_round wrap_info plugin_wrap">
<p>
Если вы хотите перенести объект из произвольной сцены, вам придется знать о его местоположении. Для создания сложно перемещающихся объектов, вам придется написать свой метод, который будет сохранять текущую позицию объекта в самом объекте и делать удаление объекта из старой сцены. Либо, если для перемещения объектов вы пользуетесь функциями из данной главы, вы можете использовать <code>where</code>. Например:
</p>
<pre class="code lua">move<span class="br0">&#40;</span>mycat<span class="sy0">,</span> here<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">,</span> where<span class="br0">&#40;</span>mycat<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span> <span class="co1">-- мой кот ходит со мной;</span></pre>

<p>
Правда при этом и первоначальное размещение объекта <code>mycat</code> должно производиться методом <code>put</code> (или <code>place</code>).
</p>
</div>
<p>
Существует также функция <code>movef</code>, аналогичная <code>move</code>, но добавляющая объект в начало списка.
</p>
<ul>
<li class="level1"><div class="li"> <code>drop(что, [где])</code> – положить объект из инвентаря на сцену:</div>
</li>
</ul>
<pre class="code lua">drop <span class="br0">&#40;</span>knife<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Существует также функция <code>dropf</code>, аналогичная <code>drop</code>, но добавляющая объект в начало списка объектов. Второй необязательный параметр – комната, куда помещается предмет. 
</p>
<ul>
<li class="level1"><div class="li"> <code>place(что, [где]) и placef(…)</code> как drop/dropf, но не удалять предмет из инвентаря;</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> <code>put(что, [где]) и putf(…)</code> устаревшая форма записи place/placef;</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> <code>replace(что, объект, [где])</code> – заменить один объект на другой в сцене или объекте <code>где</code>;</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> <code>remove(что, [где])</code> удаляет объект из текущей сцены или сцены/объекта <code>где</code>, если он не выключен; </div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> <code>purge (объект, [откуда])</code> – см. <code>remove</code>, удаляет даже выключенные объекты;</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> <code>take(что, [где])</code> – взять объект с текущей сцены или объекта/сцены заданной <code>где</code>. <code>takef</code> – вариант с добавлением в начало инвентаря. На самом деле, если объекта нет на сцене, он все равно будет добавлен в инвентарь, таким образом <code>take</code>, например, часто используется для первоначального наполнения инвентаря в <code>init</code> функции.</div>
</li>
</ul>
<pre class="code lua">	take<span class="br0">&#40;</span><span class="st0">'knife'</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>
<div class="wrap_center wrap_round wrap_important plugin_wrap">
<p>
<strong>Внимание!!!</strong>
На самом деле, эти функции также умеют работать не только с комнатами и объектами, но и со списками. То есть <code>remove(apple, inv())</code> сработает также как и <code>remove(apple, me())</code>;
Кроме того, у некоторых описанных выше функций есть варианты с постфиксом <code>to</code>: <code>placeto</code>, <code>putto</code>, <code>taketo</code>, <code>dropto</code>. У этих функций есть дополнительный параметр – индекс позиции в списке, для точного управления позицией предмета. Вы также можете вписывать позицию прямо в списках, например;
</p>
<pre class="code lua">obj <span class="sy0">=</span> <span class="br0">&#123;</span> <span class="br0">&#91;</span><span class="nu0">1</span><span class="br0">&#93;</span> <span class="sy0">=</span> <span class="st0">'apple'</span><span class="sy0">,</span> <span class="br0">&#91;</span><span class="nu0">1000</span><span class="br0">&#93;</span> <span class="sy0">=</span> <span class="st0">'floor'</span> <span class="br0">&#125;</span><span class="sy0">;</span></pre>

<p>
Но я не рекомендую пользоваться такими вещами в своих играх, если вам нужно точное позиционирование, лучше используйте объекты в объектах.
</p>
</div><ul>
<li class="level1"><div class="li"> <code>lifeon(объект, [приоритет])</code> добавить объект в список динамических («живых») объектов (будет описано дальше), приоритет – числовой параметр (положительное число), 1 – наивысший приоритет;</div>
</li>
<li class="level1"><div class="li"> <code>lifeoff(что)</code> удалить объект из списка динамических объектов;</div>
</li>
<li class="level1"><div class="li"> <code>taken(объект)</code> – если объект взят – возвратить <code>true</code> (взят с помощью <code>tak</code> или <code>take()</code>);</div>
</li>
<li class="level1"><div class="li"> <code>rnd(m)</code> – случайное целочисленное значение от <code>1</code> до <code>m</code>;</div>
</li>
<li class="level1"><div class="li"> <code>walk(куда)</code> – перейти в сцену <code>куда</code>:</div>
</li>
</ul>
<pre class="code lua">act <span class="sy0">=</span> code <span class="co2">[[
        pn &quot;Я иду в следующую комнату...&quot;
        walk (nextroom);
]]</span></pre>
<pre class="code lua">mycar <span class="sy0">=</span> obj <span class="br0">&#123;</span>
	nam <span class="sy0">=</span> <span class="st0">'моя машина'</span><span class="sy0">;</span>
	dsc <span class="sy0">=</span> <span class="st0">'Перед хижиной стоит мой старенький {пикап} Toyota.'</span><span class="sy0">;</span>
	act <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="br0">&#41;</span>
		walk<span class="br0">&#40;</span><span class="st0">'inmycar'</span><span class="br0">&#41;</span><span class="sy0">;</span>
	<span class="kw1">end</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre>
<div class="wrap_center wrap_round wrap_important plugin_wrap">
<p>
<strong>Внимание!!!</strong>
</p>

<p>
После вызова <code>walk</code> выполнение обработчика продолжится до его завершения. Поэтому обычно, после <code>walk</code> всегда следует <code>return</code>, если только это не последняя строка функции, хотя и в этом случае безопасно поставить <code>return</code>.
</p>
<pre class="code lua">act <span class="sy0">=</span> code <span class="co2">[[
        pn &quot;Я иду в следующую комнату...&quot;
        walk (nextroom);
        return
]]</span></pre>

<p>
Не забывайте также, что при вызове <code>walk</code> вызовутся обработчики <code>exit/enter/left/entered</code> и если они запрещают переход, то он не произойдет.
</p>
</div><ul>
<li class="level1"><div class="li"> <code>change_pl(игрок)</code> – переключиться на другого игрока (со своим инвентарем и позицией). При этом функция переносит действие в сцену нового игрока без вызова <code>exit/enter/left/entered</code>. Для указания сцены, на которой находится игрок, вы можете использовать атрибут <code>where</code>:</div>
</li>
</ul>
<pre class="code lua">pupkin<span class="sy0">.</span>where <span class="sy0">=</span> <span class="st0">'kitchen'</span></pre>

<p>
… или явно вызывать функцию <code>walk()</code> после change_pl().
</p>
<ul>
<li class="level1"><div class="li"> <code>walkback([куда])</code> – возвращается из сцены в прошлую (если не задано <code>куда</code>). Возврат означает, что свойство <code>from</code> не будет изменено;</div>
</li>
<li class="level1"><div class="li"> <code>back([куда])</code> – возвращается из сцены в прошлую (если не задано <code>куда</code>). Если это переход из диалога в комнату, то не вызываются: <code>dsc</code>, <code>enter</code>, <code>entered</code> у комнаты. <code>exit</code>/<code>left</code> диалога вызываются. В других случаях аналогична <code>walkback</code>.</div>
</li>
<li class="level1"><div class="li"> <code>walkin(куда)</code> – перейти в сцену, при этом <code>exit</code>/<code>left</code> текущей комнаты не вызывается;</div>
</li>
<li class="level1"><div class="li"> <code>walkout()</code> – вернуться в прошлую сцену, при этом <code>enter</code>/<code>entered</code> этой сцены не вызовется;</div>
</li>
<li class="level1"><div class="li"> <code>time()</code> – возвращает текущее время игры. Время игры считается в активных действиях игрока.</div>
</li>
<li class="level1"><div class="li"> <code>cat(…)</code> – возвращает строку – склейку строк-аргументов. Если первый аргумент <code>nil</code> – пустота, то функция возвращает <code>nil</code> – пустоту.</div>
</li>
<li class="level1"><div class="li"> <code>par(…)</code> – возвращает строку – склейку строк-аргументов, разбитых строкой-первым параметром.</div>
</li>
<li class="level1"><div class="li"> <code>disable</code>/<code>enable</code>/<code>disable_all</code>/<code>enable_all</code> – аналог одноименных методов у объекта;</div>
</li>
<li class="level1"><div class="li"> <code>visited([комната])</code>  счетчик посещений комнаты или <code>nil</code> - если мы в ней не были, если <code>комната</code> не задана, то проверяется текущая;</div>
</li>
<li class="level1"><div class="li"> <code>visits([комната])</code> аналогична <code>visited</code> за исключением того, что если посещений не было, возвращает 0, а не пустоту;</div>
</li>
<li class="level1"><div class="li"> <code>player_moved()</code> возвращает true если в данном такте игры был переход игрока между комнатами, предназначена для использования в <code>life</code> методах (описано далее);</div>
</li>
<li class="level1"><div class="li"> <code>stead.need_scene()</code> если вам необходимо, чтобы следующий такт игры вывел статическую часть сцены (и вы не хотите использовать <code>forcedsc</code>), вы можете воспользоваться этой функцией. Другим способом перерисовки сцены является переход в эту-же комнату;</div>
</li>
<li class="level1"><div class="li"> <code>stead.nameof(объект)</code> – вернуть имя объекта (<code>nam</code> атрибут);</div>
</li>
<li class="level1"><div class="li"> <code>stead.dispof(объект)</code> – вернуть результат <code>disp</code>, а если его нет – <code>nam</code>;</div>
</li>
<li class="level1"><div class="li"> <code>disabled(объект)</code> – возвращает <code>true</code>, если объект отключен;</div>
</li>
<li class="level1"><div class="li"> <code>stead.call(дескриптор, строка - имя атрибута/обработчика, параметры…)</code> – вызов обработчика или получение значения атрибута (описано далее);</div>
</li>
</ul>

</div>
<!-- EDIT18 SECTION "13. Другие функции INSTEAD" [93359-104273] -->
<h1 class="sectionedit19" id="диалоги">14. Диалоги</h1>
<div class="level1">

<p>
<em>Диалоги</em> – это сцены специального типа <code>dlg</code>, содержащие объекты – фразы. В INSTEAD на данный момент существует два способа описания диалогов: <em>расширенный</em> и <em>простой</em>. Простой способ считается устаревшим, и не рекомендуется для новых игр. Рассмотрим оба способа.
</p>

<p>
Общим для обоих способов является сама архитектура, по которой работает диалог.
</p>

<p>
При входе в диалог игрок видит перечень фраз (по-умолчанию, пронумерованных), которые может выбирать, получая какую-то реакцию игры. По умолчанию, уже выбранные фразы скрываются. При исчерпании всех вариантов, диалог завершается выходом в предыдущую комнату (конечно, если в диалоге нет постоянно видимых фраз, среди которых обычно встречается что-то типа <code>Завершить разговор</code> или <code>Спросить еще раз</code>). 
</p>

<p>
Переход в диалог в игре осуществляется как переход на сцену:
</p>
<pre class="code lua">povar <span class="sy0">=</span> obj <span class="br0">&#123;</span>
	nam <span class="sy0">=</span> <span class="st0">'повар'</span><span class="sy0">;</span>
	dsc <span class="sy0">=</span> <span class="st0">'Я вижу {повара}.'</span><span class="sy0">;</span>
	act <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span><span class="br0">&#41;</span>
		walk <span class="st0">'povardlg'</span>
	<span class="kw1">end</span><span class="sy0">,</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre>

<p>
Хотя я рекомендую использовать <code>walkin</code>, так как в случае <code>walkin</code> не вызываются <code>exit/left</code> текущей комнаты, а персонаж, с которым мы можем поговорить, обычно находиться в этой же комнате, где и главный герой. То есть:
</p>
<pre class="code lua">povar <span class="sy0">=</span> obj <span class="br0">&#123;</span>
	nam <span class="sy0">=</span> <span class="st0">'повар'</span><span class="sy0">;</span>
	dsc <span class="sy0">=</span> <span class="st0">'Я вижу {повара}.'</span><span class="sy0">;</span>
	act <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span><span class="br0">&#41;</span>
		walkin <span class="st0">'povardlg'</span>
	<span class="kw1">end</span><span class="sy0">,</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre>

<p>
Вы можете делать переход из одного диалога в другой, организуя иерархичность диалогов (при необходимости делая возврат на предыдущий уровень с помощью <code>back()</code>), впрочем, в расширенных диалогах иерархичность организована более просто.
</p>

<p>
Если вам не нравится префикс у фразы в виде цифры, вы можете определить строковую переменную:
</p>
<pre class="code lua">stead<span class="sy0">.</span>phrase_prefix <span class="sy0">=</span> <span class="st0">'--'</span><span class="sy0">;</span></pre>

<p>
И получить префикс в виде тире перед каждой фразой.
</p>

<p>
Обратите внимание, что <code>stead.phrase_prefix</code> не сохраняется, если вам нужно переопределять ее на лету, вам придется восстанавливать ее состояние в <code>start</code> функции вручную!
</p>
<div class="wrap_center wrap_round wrap_important plugin_wrap">
<p>
<strong>Внимание!!!</strong>
Если в диалоге нет ни одной фразы, движок по умолчанию блокирует переход в такой диалог <span class="wrap_hi wrap_em ">(ведь из него нет выхода!)</span>. Имейте это в виду при отладке своей игры.
</p>
</div><div class="wrap_center wrap_round wrap_important plugin_wrap">
<p>
<strong>Внимание!!!</strong>
Я настоятельно рекомендую использовать модуль <code>hideinv</code> и задавать свойство <code>hideinv</code> в диалогах. Диалоги будут выглядеть красивей и вы обезопасите свою игру от ошибок и непредсказуемых реакций при использовании инвентаря внутри диалога (так как обычно автор не подразумевает такие вещи). Например:
</p>
<pre class="code lua">instead_version <span class="st0">&quot;1.8.2&quot;</span>
<span class="kw3">require</span> <span class="st0">&quot;hideinv&quot;</span>
<span class="sy0">...</span>
guarddlg <span class="sy0">=</span> dlg <span class="br0">&#123;</span>
        nam <span class="sy0">=</span> <span class="st0">'Охранник'</span><span class="sy0">;</span>
        <span class="co1">-- в диалогах обычно не нужен инвентарь</span>
        hideinv <span class="sy0">=</span> <span class="kw4">true</span><span class="sy0">;</span> 
        <span class="sy0">...</span>
<span class="br0">&#125;</span></pre>
</div>
</div>
<!-- EDIT19 SECTION "14. Диалоги" [104274-108676] -->
<h2 class="sectionedit20" id="расширенные_диалоги">Расширенные диалоги</h2>
<div class="level2">

<p>
Начиная с версии INSTEAD 1.7.0 поддерживается новый более простой и мощный синтаксис диалогов, по сравнению с устаревшим традиционным. Фразы определяются в атрибуте <code>phr</code> диалога, например:
</p>
<pre class="code lua">povardlg <span class="sy0">=</span> dlg <span class="br0">&#123;</span>
	nam <span class="sy0">=</span> <span class="st0">'На кухне'</span><span class="sy0">;</span>
        hideinv <span class="sy0">=</span> <span class="kw4">true</span><span class="sy0">;</span>
	entered <span class="sy0">=</span> <span class="co2">[[Передо мной полное лицо женщины - 
                 повара в белом колпаке и усталым взглядом...]]</span><span class="sy0">;</span>
	phr <span class="sy0">=</span> <span class="br0">&#123;</span>
	    <span class="br0">&#123;</span> always <span class="sy0">=</span> <span class="kw4">true</span><span class="sy0">,</span> <span class="st0">'Мне вот-этих зелененьких... Ага -- и бобов!'</span><span class="sy0">,</span> 
                             <span class="st0">'На здоровье!'</span><span class="br0">&#125;</span><span class="sy0">;</span>
	    <span class="br0">&#123;</span> always <span class="sy0">=</span> <span class="kw4">true</span><span class="sy0">,</span> <span class="st0">'Картошку с салом, пожалуйста!'</span><span class="sy0">,</span> 
                             <span class="st0">'Приятного аппетита!'</span><span class="br0">&#125;</span><span class="sy0">;</span>
	    <span class="br0">&#123;</span> always <span class="sy0">=</span> <span class="kw4">true</span><span class="sy0">,</span> <span class="st0">'Две порции чесночного супа!!!'</span><span class="sy0">,</span> 
                             <span class="st0">'Прекрасный выбор!'</span> <span class="br0">&#125;</span><span class="sy0">;</span>
	    <span class="br0">&#123;</span> always <span class="sy0">=</span> <span class="kw4">true</span><span class="sy0">,</span> <span class="st0">'Мне что-нибудь легонькое, у меня язва...'</span><span class="sy0">,</span> 
                             <span class="st0">'Овсянка!'</span> <span class="br0">&#125;</span><span class="sy0">;</span>
            <span class="br0">&#123;</span> always <span class="sy0">=</span> <span class="kw4">true</span><span class="sy0">,</span> <span class="st0">'Спасибо, мне ничего не нужно.'</span><span class="sy0">,</span> 
                             <span class="st0">'Как пожелаете.'</span><span class="sy0">,</span> <span class="co2">[[ back() ]]</span> <span class="br0">&#125;</span><span class="sy0">;</span>
	<span class="br0">&#125;</span><span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre>

<p>
Имейте в виду, что если в диалоге не определен атрибут <code>dsc</code>, то он формируется движком таким образом, чтобы отражать последнюю реакцию диалога, то есть, если игрок нажмет на заголовок сцены он увидит последний ответ на свою реплику еще раз. Если вы рассчитываете на такое поведение диалога, то первоначальную реакцию диалога удобнее всего вписать в <code>entered</code>, как в примере выше. Я не рекомендую переопределять <code>dsc</code> у диалогов расширенного типа.
</p>

<p>
Каждая фраза имеет вид:
</p>
<pre class="code lua"><span class="br0">&#123;</span> <span class="br0">&#91;</span>номер или tag<span class="sy0">=</span>тэг<span class="sy0">,</span><span class="br0">&#93;</span><span class="br0">&#91;</span><span class="kw4">false</span> если выключена<span class="sy0">,</span><span class="br0">&#93;</span><span class="br0">&#91;</span>always <span class="sy0">=</span> <span class="kw4">true</span><span class="br0">&#93;</span><span class="sy0">,</span>
         <span class="st0">&quot;Вопрос&quot;</span><span class="sy0">,</span> <span class="st0">&quot;Ответ&quot;</span><span class="sy0">,</span> <span class="co2">[[ необязательный код  - реакция]]</span> <span class="br0">&#125;</span><span class="sy0">,</span></pre>

<p>
Фраза содержит <em>вопрос</em>, <em>ответ</em> и <em>реакцию</em>. Когда игрок выбирает одну из фраз (кликнув на нее), выводится ответ, фраза отключается, а затем срабатывает <em>реакция</em> (если она есть). Когда все фразы отключатся, <em>ветвь</em> диалога заканчивается. <em>Реакция</em> – это строка кода на lua, который выполнится после отключения фразы. 
</p>

<p>
В реакции может быть любой lua код, но обычно, он содержит в себе логику по работе с фразами. 
</p>

<p>
INSTEAD предоставляет следующие функции по работе с фразами:
</p>
<ul>
<li class="level1"><div class="li"> <code>pon(t..)</code> – включить фразы диалога с номерами или тегами t… </div>
</li>
<li class="level1"><div class="li"> <code>poff(t…)</code> – выключить фразы диалога с номерами или тегами t…</div>
</li>
<li class="level1"><div class="li"> <code>prem(t…)</code> – удалить (заблокировать) фразы  диалога с номерами или тегами t… (удаление означает невозможность включения фраз. <code>pon(t…)</code> не приведет к включению фраз).</div>
</li>
<li class="level1"><div class="li"> <code>pseen(t…)</code> – вернет <code>true</code>, если все заданные фразы диалога (заданными номерами или тегами) видимы.</div>
</li>
<li class="level1"><div class="li"> <code>punseen(t…)</code> – вернет <code>true</code>, если все заданные фразы диалога (заданные номерами или тегами) невидимы.</div>
</li>
</ul>

<p>
Если параметр <code>t</code> не указан, действие относится к текущей фразе (в контексте которой был вызван код).
</p>

<p>
Если вам необходимо работать с фразами другого диалога (который не является в данный момент текущей комнатой), используйте вызовы в виде методов: <code>комната:метод()</code>, например, <code>guard_dlg:pon(&#039;show_card&#039;)</code>.
</p>

<p>
Вы можете определить в диалоге выключенную фразу, а затем, включить ее:
</p>
<pre class="code lua">povardlg <span class="sy0">=</span> dlg <span class="br0">&#123;</span>
	nam <span class="sy0">=</span> <span class="st0">'На кухне'</span><span class="sy0">;</span>
        hideinv <span class="sy0">=</span> <span class="kw4">true</span><span class="sy0">;</span>
	entered <span class="sy0">=</span> <span class="co2">[[Передо мной полное лицо женщины - 
               повара в белом колпаке и усталым взглядом...]]</span><span class="sy0">;</span>
	phr <span class="sy0">=</span> <span class="br0">&#123;</span>
            <span class="co1">-- выключенная фраза</span>
            <span class="br0">&#123;</span> <span class="nu0">1</span><span class="sy0">,</span> <span class="kw4">false</span><span class="sy0">,</span> always <span class="sy0">=</span> <span class="kw4">true</span><span class="sy0">,</span>  
                <span class="co1">-- для наглядности, вы можете использовать переносы строк</span>
                <span class="co2">[[Дайте мне французских булок!]]</span><span class="sy0">,</span> 
                <span class="co2">[[Конечно...]]</span> <span class="br0">&#125;</span><span class="sy0">;</span> 
            <span class="co1">-- знаем про булки, включить фразу</span>
            <span class="br0">&#123;</span> <span class="co2">[[А что у вас там, на полке?]]</span><span class="sy0">,</span> 
              <span class="co2">[[Это французские булки.]]</span><span class="sy0">,</span> 
              <span class="co2">[[ pon(1) ]]</span> <span class="br0">&#125;</span><span class="sy0">;</span> 
            <span class="br0">&#123;</span> always <span class="sy0">=</span> <span class="kw4">true</span><span class="sy0">,</span> <span class="st0">'Мне вот-этих зелененьких... Ага -- и бобов!'</span><span class="sy0">,</span> 
                             <span class="st0">'На здоровье!'</span><span class="br0">&#125;</span><span class="sy0">;</span>
            <span class="br0">&#123;</span> always <span class="sy0">=</span> <span class="kw4">true</span><span class="sy0">,</span> <span class="st0">'Картошку с салом, пожалуйста!'</span><span class="sy0">,</span> 
                             <span class="st0">'Приятного аппетита!'</span><span class="br0">&#125;</span><span class="sy0">;</span>
            <span class="br0">&#123;</span> always <span class="sy0">=</span> <span class="kw4">true</span><span class="sy0">,</span> <span class="st0">'Спасибо, мне ничего не нужно.'</span><span class="sy0">,</span> 
                             <span class="st0">'Как пожелаете.'</span><span class="sy0">,</span> <span class="co2">[[ back() ]]</span> <span class="br0">&#125;</span><span class="sy0">;</span>
	<span class="br0">&#125;</span><span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre>

<p>
Итак, как вы уже поняли, для идентификации фразы вы можете использовать номер, например:
</p>
<pre class="code lua"><span class="br0">&#123;</span> <span class="nu0">2</span><span class="sy0">,</span> <span class="st0">&quot;Вопрос?&quot;</span><span class="sy0">,</span> <span class="st0">&quot;Ответ!&quot;</span> <span class="br0">&#125;</span><span class="sy0">;</span></pre>

<p>
Для сложных диалогов более удобными являются теги, например:
</p>
<pre class="code lua"><span class="br0">&#123;</span> tag <span class="sy0">=</span> <span class="st0">'exit'</span><span class="sy0">,</span> <span class="st0">&quot;Ну ладно, я пошел!&quot;</span><span class="sy0">,</span> code <span class="co2">[[ back() ]]</span> <span class="br0">&#125;</span><span class="sy0">;</span></pre>

<p>
Если вам не нужно идентифицировать фразу, просто опускайте первое поле:
</p>
<pre class="code lua"><span class="br0">&#123;</span> <span class="st0">&quot;Вопрос?&quot;</span><span class="sy0">,</span> <span class="st0">&quot;Ответ!&quot;</span> <span class="br0">&#125;</span><span class="sy0">;</span></pre>

<p>
Как видно, <code>тег</code> – это текстовая метка фразы. Как уже было замечено, вы можете делать <code>pon/poff/pseen/punseen</code> как с пронумерованными фразами, так и с фразами, имеющими тег. В случае, если один и тот же тег стоит у нескольких фраз, то действие применяется на все фразы с одинаковым тегом. Для функции <code>pseen</code>, видимость тега означает наличие хотя бы одной фразы с таким тегом, для функции <code>punseen</code> – отсутствие включенных фраз с заданным тегом.
</p>

<p>
<em>Вы можете присваивать тег и пронумерованной фразе, если это требуется.</em>
</p>

<p>
Присутствие в фразе <code>always = true</code> означает, что фраза не будет автоматически выключена при ее срабатывании:
</p>
<pre class="code lua"><span class="br0">&#123;</span> tag <span class="sy0">=</span> <span class="st0">'exit'</span><span class="sy0">,</span> always <span class="sy0">=</span> <span class="kw4">true</span><span class="sy0">,</span> <span class="st0">&quot;Ну ладно, я пошел!&quot;</span><span class="sy0">,</span> code <span class="co2">[[ back() ]]</span> <span class="br0">&#125;</span></pre>

<p>
Если необходимо опустить ответ фразы и всю реакцию описать в параметре «необязательный код», то следующие варианты записи являются допустимыми:
</p>
<pre class="code lua"><span class="br0">&#123;</span> tag <span class="sy0">=</span> <span class="st0">'exit'</span><span class="sy0">,</span> always <span class="sy0">=</span> <span class="kw4">true</span><span class="sy0">,</span> <span class="st0">&quot;Ну ладно, я пошел!&quot;</span><span class="sy0">,</span> <span class="kw4">nil</span><span class="sy0">,</span> <span class="co2">[[ back() ]]</span> <span class="br0">&#125;</span><span class="sy0">,</span>
<span class="br0">&#123;</span> tag <span class="sy0">=</span> <span class="st0">'exit'</span><span class="sy0">,</span> always <span class="sy0">=</span> <span class="kw4">true</span><span class="sy0">,</span> <span class="st0">&quot;Ну ладно, я пошел!&quot;</span><span class="sy0">,</span> code <span class="sy0">=</span> <span class="co2">[[ back() ]]</span> <span class="br0">&#125;</span></pre>

<p>
Вы также можете задавать <em>вопрос</em> и <em>ответ</em> в виде функций или <code>code</code>.
</p>
<pre class="code lua"><span class="br0">&#123;</span> tag <span class="sy0">=</span> <span class="st0">'exit'</span><span class="sy0">,</span> code <span class="co2">[[ p &quot;Ну ладно, я пошел!&quot; ]]</span><span class="sy0">,</span> 
                code <span class="co2">[[ p &quot;Может, останешься?&quot;; pon 'really' ]]</span> <span class="br0">&#125;</span><span class="sy0">,</span>
<span class="br0">&#123;</span> tag <span class="sy0">=</span> <span class="st0">'really'</span><span class="sy0">,</span> <span class="kw4">false</span><span class="sy0">,</span> 
  always <span class="sy0">=</span> <span class="kw4">true</span><span class="sy0">,</span> 
  <span class="st0">&quot;Я точно пошел!&quot;</span><span class="sy0">,</span> 
  <span class="kw1">function</span><span class="br0">&#40;</span><span class="br0">&#41;</span> back<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="kw1">end</span> <span class="br0">&#125;</span> <span class="co1">-- эта фраза выключена и включается предыдущей</span></pre>

<p>
Вы можете группировать фразы диалога в <em>ветви</em>, тем самым организуя иерархические диалоги без необходимости массового использования <code>pon/poff</code> и перехода между несколькими <code>dlg</code>. 
</p>

<p>
<em>Группа фраз</em> – это набор фраз, отделенная от другой группы фразой, у которой нет реакции (пример такой простейшей фразы это пара скобок {}). Например:
</p>
<pre class="code lua"><span class="br0">&#123;</span> <span class="st0">'Расскажи что-нибудь о погоде?'</span><span class="sy0">,</span> 
    <span class="st0">'Хорошо, что тебя интересует?'</span><span class="sy0">,</span> <span class="co2">[[ psub 'погода' ]]</span> <span class="br0">&#125;</span><span class="sy0">,</span>
<span class="br0">&#123;</span> always<span class="sy0">=</span><span class="kw4">true</span><span class="sy0">,</span> <span class="co2">[[Пока!]]</span><span class="sy0">,</span> code <span class="sy0">=</span> <span class="co2">[[ back() ]]</span> <span class="br0">&#125;</span><span class="sy0">,</span>    
<span class="br0">&#123;</span> tag <span class="sy0">=</span> <span class="st0">'погода'</span> <span class="br0">&#125;</span><span class="sy0">,</span>
<span class="br0">&#123;</span> <span class="st0">'Какая температура?'</span><span class="sy0">,</span> <span class="st0">'25 градусов!'</span> <span class="br0">&#125;</span><span class="sy0">,</span>
<span class="br0">&#123;</span> <span class="st0">'Какая влажность?'</span><span class="sy0">,</span> <span class="st0">'80%'</span> <span class="br0">&#125;</span><span class="sy0">,</span></pre>

<p>
В диалоге показывается только текущая группа фраз. В примере выше мы видим две группы. При входе в диалог, игрок увидит выбор из двух фраз: «Расскажи что-нибудь…» и «Пока!». Выбрав первую фразу, он попадет в подветку с тегом &#039;погода&#039;, в которой увидит два вопроса (о температуре и влажности). Когда он задаст оба вопроса, то переместится снова на первую ветку, где останется активной только одна фраза: «Пока!».
</p>

<p>
В данном примере группы разделены фразой: { tag = &#039;погода&#039; }, но также точно разделителем могла стать пустая фраза без тега:
</p>
<pre class="code lua"><span class="br0">&#123;</span> <span class="st0">'Расскажи что-нибудь о погоде?'</span><span class="sy0">,</span> 
    <span class="st0">'Хорошо, что тебя интересует?'</span><span class="sy0">,</span> <span class="co2">[[ psub 'погода' ]]</span> <span class="br0">&#125;</span><span class="sy0">,</span>
<span class="br0">&#123;</span> always<span class="sy0">=</span><span class="st0">&quot;true&quot;</span><span class="sy0">,</span> <span class="co2">[[Пока!]]</span><span class="sy0">,</span> code <span class="sy0">=</span> <span class="co2">[[ back() ]]</span> <span class="br0">&#125;</span><span class="sy0">,</span>    
<span class="br0">&#123;</span> <span class="br0">&#125;</span><span class="sy0">,</span>
<span class="br0">&#123;</span> tag <span class="sy0">=</span> <span class="st0">'погода'</span><span class="sy0">,</span> <span class="st0">'Какая температура?'</span><span class="sy0">,</span> <span class="st0">'25 градусов!'</span> <span class="br0">&#125;</span><span class="sy0">,</span>
<span class="br0">&#123;</span> <span class="st0">'Какая влажность?'</span><span class="sy0">,</span> <span class="st0">'80%'</span> <span class="br0">&#125;</span><span class="sy0">,</span></pre>

<p>
Переход на ветку осуществляется с помощью команд:
</p>
<ul>
<li class="level1"><div class="li"> <code>psub</code> – переход с возвратом. Если все ответы ветки были исчерпаны или явно, с помощью <code>pret()</code>;</div>
</li>
<li class="level1"><div class="li"> <code>pjump</code> - безусловный переход;</div>
</li>
<li class="level1"><div class="li"> <code>pstart</code> - безусловный переход с обнулением истории переходов по <code>psub</code>.</div>
</li>
</ul>

<p>
В качестве аргумента <code>psub/pstart/pjump</code> может быть указан номер или тег. Вы можете использовать эти функции и извне диалога, аналогично <code>pon/poff</code> и т.д, с помощью записи: <code>диалог:метод()</code>, например: <code>shopdlg:pstart(1)</code>
</p>

<p>
Для того, чтобы узнать текущую подветку, используйте методы диалога <code>диалог:current()</code> и <code>диалог:curtag()</code>. Первый всегда возвращает номер, а второй – тег.
</p>

<p>
Проверку состояния ветки можно осуществить с помощью функций:
</p>
<ul>
<li class="level1"><div class="li"> <code>диалог:empty([t])</code>;</div>
</li>
<li class="level1"><div class="li"> <code>диалог:visible([t])</code>;</div>
</li>
</ul>

<p>
Обе функции могут получать параметр – номер или тег фразы, с которой начинается анализ группы. <code>:empty()</code> возвращает <code>true</code>, в случае, если в группе нет активных фраз. <code>:visible()</code> возвращает число видимых фраз (0 – если группа пуста). В случае, если параметр не указан, анализируется текущая группа.
</p>

<p>
В случае перехода по <code>psub/pstart/pjump</code>, первая фраза, на который выполняется переход, может служить заголовком группы фраз.
</p>

<p>
Например:
</p>
<pre class="code lua"><span class="br0">&#123;</span> <span class="st0">'Расскажи что-нибудь о погоде?'</span><span class="sy0">,</span> code <span class="sy0">=</span> <span class="co2">[[ psub 'погода' ]]</span> <span class="br0">&#125;</span><span class="sy0">,</span>
<span class="br0">&#123;</span> always<span class="sy0">=</span><span class="kw4">true</span><span class="sy0">,</span> <span class="co2">[[Пока!]]</span><span class="sy0">,</span> code <span class="sy0">=</span> <span class="co2">[[ back() ]]</span> <span class="br0">&#125;</span><span class="sy0">,</span>    
<span class="br0">&#123;</span> <span class="br0">&#125;</span><span class="sy0">,</span>
<span class="br0">&#123;</span> tag <span class="sy0">=</span> <span class="st0">'погода'</span><span class="sy0">,</span> <span class="st0">&quot;Хорошо, что тебя интересует?&quot;</span> <span class="br0">&#125;</span><span class="sy0">,</span>
<span class="br0">&#123;</span> <span class="st0">'Какая температура?'</span><span class="sy0">,</span> <span class="st0">'25 градусов!'</span> <span class="br0">&#125;</span><span class="sy0">,</span>
<span class="br0">&#123;</span> <span class="st0">'Какая влажность?'</span><span class="sy0">,</span> <span class="st0">'80%'</span> <span class="br0">&#125;</span><span class="sy0">,</span></pre>

<p>
Фраза с тегом &#039;погода&#039; не содержит в себе реакцию, и выполняет роль заголовка ветки. При переходе на ветку &#039;погода&#039; с помощью psub будет выведен текст «Хорошо, что тебя интересует?».
</p>

<p>
Как вы знаете, вопрос может быть функцией, тем самым позволяя выполнять код при переходе между ветками:
</p>
<pre class="code lua"><span class="br0">&#123;</span> <span class="st0">'Расскажи что-нибудь о погоде?'</span><span class="sy0">,</span> code <span class="sy0">=</span> <span class="co2">[[ psub 'погода' ]]</span> <span class="br0">&#125;</span><span class="sy0">,</span>
<span class="br0">&#123;</span> always<span class="sy0">=</span><span class="kw4">true</span><span class="sy0">,</span> <span class="co2">[[Пока!]]</span><span class="sy0">,</span> code <span class="sy0">=</span> <span class="co2">[[ back() ]]</span> <span class="br0">&#125;</span><span class="sy0">,</span>    
<span class="br0">&#123;</span> <span class="br0">&#125;</span><span class="sy0">,</span>
<span class="br0">&#123;</span> tag <span class="sy0">=</span> <span class="st0">'погода'</span><span class="sy0">,</span> <span class="kw1">function</span><span class="br0">&#40;</span><span class="br0">&#41;</span> 
          p <span class="st0">&quot;Хорошо, что тебя интересует?&quot;</span><span class="sy0">;</span> 
          weather_asked <span class="sy0">=</span> <span class="kw4">true</span><span class="sy0">;</span> 
<span class="kw1">end</span> <span class="br0">&#125;</span><span class="sy0">,</span>
<span class="br0">&#123;</span> <span class="st0">'Какая температура?'</span><span class="sy0">,</span> <span class="st0">'25 градусов!'</span> <span class="br0">&#125;</span><span class="sy0">,</span>
<span class="br0">&#123;</span> <span class="st0">'Какая влажность?'</span><span class="sy0">,</span> <span class="st0">'80%'</span> <span class="br0">&#125;</span><span class="sy0">,</span></pre>

<p>
Кроме того, заголовок группы может содержать метод <code>empty</code>, который вызывается в ситуации, когда все вопросы данной группы исчерпаны:
</p>
<pre class="code lua"><span class="br0">&#123;</span> <span class="st0">'Расскажи что-нибудь о погоде?'</span><span class="sy0">,</span> code <span class="sy0">=</span> <span class="co2">[[ psub 'погода' ]]</span> <span class="br0">&#125;</span><span class="sy0">,</span>
<span class="br0">&#123;</span> always<span class="sy0">=</span><span class="kw4">true</span><span class="sy0">,</span> <span class="co2">[[Пока!]]</span><span class="sy0">,</span> code <span class="sy0">=</span> <span class="co2">[[ back() ]]</span> <span class="br0">&#125;</span><span class="sy0">,</span>    
<span class="br0">&#123;</span> <span class="br0">&#125;</span><span class="sy0">,</span>
<span class="br0">&#123;</span> tag <span class="sy0">=</span> <span class="st0">'погода'</span><span class="sy0">,</span> <span class="st0">&quot;Хорошо, что тебя интересует?&quot;</span><span class="sy0">,</span>
    empty <span class="sy0">=</span> code <span class="co2">[[ p &quot;Хватит о погоде...&quot;; pret() ]]</span> <span class="br0">&#125;</span><span class="sy0">,</span>
<span class="br0">&#123;</span> <span class="st0">'Какая температура?'</span><span class="sy0">,</span> <span class="st0">'25 градусов!'</span> <span class="br0">&#125;</span><span class="sy0">,</span>
<span class="br0">&#123;</span> <span class="st0">'Какая влажность?'</span><span class="sy0">,</span> <span class="st0">'80%'</span> <span class="br0">&#125;</span><span class="sy0">,</span></pre>

<p>
<code>empty</code> вызывается в ситуации, когда в ветке не остается фраз. Если empty не определена, то действие по-умолчанию это возврат по <code>pret()</code>. Если вы переопределяете <code>empty</code>, вам придется вызвать <code>pret()</code> явно, если это требуется.
</p>

<p>
На самом деле, написание диалога не такая сложная штука, как может показаться. В большинстве случаев используется небольшое подмножество возможностей движка. 
</p>

<p>
Законченный пример реализации <em>сложного</em> диалога, вы можете посмотреть здесь: <a href="http://instead.googlecode.com/svn/trunk/doc/examples/dialog/main.lua" class="urlextern" title="http://instead.googlecode.com/svn/trunk/doc/examples/dialog/main.lua"  rel="nofollow">http://instead.googlecode.com/svn/trunk/doc/examples/dialog/main.lua</a>
</p>

</div>
<!-- EDIT20 SECTION "Расширенные диалоги" [108677-124813] -->
<h2 class="sectionedit21" id="простые_диалоги">Простые диалоги</h2>
<div class="level2">

<p>
Данный фрагмент документации содержит описание устаревшего синтаксиса, тем не менее, если вам не понятна идея диалогов из предыдущей части, возможно, этот фрагмент вам поможет, так как некоторые вещи являются общими для обоих вариантов диалогов.
</p>

<p>
Простейший диалог в старом синтаксисие может выглядеть следующим образом:
</p>
<pre class="code lua">povardlg <span class="sy0">=</span> dlg <span class="br0">&#123;</span>
	nam <span class="sy0">=</span> <span class="st0">'На кухне'</span><span class="sy0">;</span>
	dsc <span class="sy0">=</span> <span class="co2">[[Передо мной полное лицо женщины - 
              повара в белом колпаке и усталым взглядом...]]</span><span class="sy0">;</span>
	obj <span class="sy0">=</span> <span class="br0">&#123;</span>
	<span class="br0">&#91;</span><span class="nu0">1</span><span class="br0">&#93;</span> <span class="sy0">=</span> phr<span class="br0">&#40;</span><span class="st0">'Мне вот-этих зелененьких... Ага -- и бобов!'</span><span class="sy0">,</span> <span class="st0">'На здоровье!'</span><span class="br0">&#41;</span><span class="sy0">,</span>
	<span class="br0">&#91;</span><span class="nu0">2</span><span class="br0">&#93;</span> <span class="sy0">=</span> phr<span class="br0">&#40;</span><span class="st0">'Картошку с салом, пожалуйста!'</span><span class="sy0">,</span> <span class="st0">'Приятного аппетита!'</span><span class="br0">&#41;</span><span class="sy0">,</span>
	<span class="br0">&#91;</span><span class="nu0">3</span><span class="br0">&#93;</span> <span class="sy0">=</span> phr<span class="br0">&#40;</span><span class="st0">'Две порции чесночного супа!!!'</span><span class="sy0">,</span> <span class="st0">'Прекрасный выбор!'</span><span class="br0">&#41;</span><span class="sy0">,</span>
	<span class="br0">&#91;</span><span class="nu0">4</span><span class="br0">&#93;</span> <span class="sy0">=</span> phr<span class="br0">&#40;</span><span class="st0">'Мне что-нибудь легонькое, у меня язва...'</span><span class="sy0">,</span> <span class="st0">'Овсянка!'</span><span class="br0">&#41;</span><span class="sy0">,</span>
	<span class="br0">&#125;</span><span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre>

<p>
<code>phr</code> – создание фразы. Фраза содержит <em>вопрос</em>, <em>ответ</em> и <em>реакцию</em> (реакция в данном примере отсутствует). Когда игрок выбирает одну из фраз, фраза отключается. Когда все фразы отключатся диалог заканчивается. <em>Реакция</em> – это строка кода на lua, который выполнится после отключения фразы. Например:
</p>
<pre class="code lua">food <span class="sy0">=</span> obj <span class="br0">&#123;</span>
	nam <span class="sy0">=</span> <span class="st0">'еда'</span><span class="sy0">,</span>
	inv <span class="sy0">=</span> <span class="kw1">function</span> <span class="br0">&#40;</span>s<span class="br0">&#41;</span>
		iremove<span class="br0">&#40;</span><span class="st0">'food'</span><span class="sy0">,</span> inv<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
		p <span class="st0">'Я ем.'</span><span class="sy0">;</span>
	<span class="kw1">end</span>
<span class="br0">&#125;</span><span class="sy0">;</span>
&nbsp;
gotfood <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>w<span class="br0">&#41;</span>
	take <span class="st0">'food'</span><span class="sy0">;</span>
	food<span class="sy0">.</span>_num <span class="sy0">=</span> w<span class="sy0">;</span>
	back<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="kw1">end</span>
&nbsp;
povardlg <span class="sy0">=</span> dlg <span class="br0">&#123;</span>
	nam <span class="sy0">=</span> <span class="st0">'На кухне'</span><span class="sy0">;</span>
	dsc <span class="sy0">=</span> <span class="co2">[[Передо мной полное лицо женщины - 
                повара в белом колпаке и усталым взглядом...]]</span><span class="sy0">;</span>
	obj <span class="sy0">=</span> <span class="br0">&#123;</span>
	<span class="br0">&#91;</span><span class="nu0">1</span><span class="br0">&#93;</span> <span class="sy0">=</span> phr<span class="br0">&#40;</span><span class="st0">'Мне вот-этих зелененьких... Ага -- и бобов!'</span><span class="sy0">,</span> 
                  <span class="st0">'На здоровье!'</span><span class="sy0">,</span> <span class="co2">[[pon(); gotfood(1);]]</span><span class="br0">&#41;</span><span class="sy0">,</span>
	<span class="br0">&#91;</span><span class="nu0">2</span><span class="br0">&#93;</span> <span class="sy0">=</span> phr<span class="br0">&#40;</span><span class="st0">'Картошку с салом, пожалуйста!'</span><span class="sy0">,</span> 
                  <span class="st0">'Приятного аппетита!'</span><span class="sy0">,</span> <span class="co2">[[pon(); gotfood(2);]]</span><span class="br0">&#41;</span><span class="sy0">,</span>
	<span class="br0">&#91;</span><span class="nu0">3</span><span class="br0">&#93;</span> <span class="sy0">=</span> phr<span class="br0">&#40;</span><span class="st0">'Две порции чесночного супа!!!'</span><span class="sy0">,</span> 
                  <span class="st0">'Прекрасный выбор!'</span><span class="sy0">,</span> <span class="co2">[[pon();gotfood(3);]]</span><span class="br0">&#41;</span><span class="sy0">,</span>
	<span class="br0">&#91;</span><span class="nu0">4</span><span class="br0">&#93;</span> <span class="sy0">=</span> phr<span class="br0">&#40;</span><span class="st0">'Мне что-нибудь легонькое, у меня язва...'</span><span class="sy0">,</span> 
                  <span class="st0">'Овсянка!'</span><span class="sy0">,</span> <span class="co2">[[pon(); gotfood(4);]]</span><span class="br0">&#41;</span><span class="sy0">,</span>
	<span class="br0">&#125;</span><span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre>

<p>
В данном примере, игрок выбирает еду. Получает ее (запомнив выбор в переменной food._num) и возвращается обратно (в ту сцену откуда попал в диалог).
</p>

<p>
В реакции может быть любой lua код, но, как и в случае с расширенными диалогами, обычно в нем содержится логика по управлению фразами. <code>pon/poff/prem/pseen/punseen</code> работают только с номерами (так как тегов здесь нет).
</p>

<p>
Вы можете переходить из одного диалога в другой диалог, организовывая иерархические диалоги. 
</p>

<p>
Также, вы можете прятать некоторые фразы при инициализации диалога и показывать их при некоторых условиях.
</p>
<pre class="code lua">facectrl <span class="sy0">=</span> dlg <span class="br0">&#123;</span>
	nam <span class="sy0">=</span> <span class="st0">'Фэйсконтроль'</span><span class="sy0">;</span>
	dsc <span class="sy0">=</span> <span class="st0">'Я вижу перед собой неприятное лицо полного охранника.'</span><span class="sy0">;</span>
	obj <span class="sy0">=</span> <span class="br0">&#123;</span>
		<span class="br0">&#91;</span><span class="nu0">1</span><span class="br0">&#93;</span> <span class="sy0">=</span> phr<span class="br0">&#40;</span><span class="st0">'Я пришел послушать лекцию Белина...'</span><span class="sy0">,</span> 
		<span class="co2">[[-- Я не знаю кто вы -- ухмыляется охранник -- 
                     но мне велели пускать сюда только приличных людей.]]</span><span class="sy0">,</span>
		<span class="co2">[[pon(2);]]</span><span class="br0">&#41;</span><span class="sy0">,</span>
		<span class="br0">&#91;</span><span class="nu0">2</span><span class="br0">&#93;</span> <span class="sy0">=</span> _phr<span class="br0">&#40;</span><span class="st0">'У меня есть приглашение!'</span><span class="sy0">,</span> 
		<span class="co2">[[-- А мне плевать! Посмотри на себя в зеркало!!! 
                    Ты пришел слушать самого Белина -- правую руку самого... 
                    -- охранник почтительно помолчал -- Так что пошел вон..]]</span><span class="sy0">,</span> <span class="co2">[[pon(3,4)]]</span><span class="br0">&#41;</span><span class="sy0">,</span>
		<span class="br0">&#91;</span><span class="nu0">3</span><span class="br0">&#93;</span> <span class="sy0">=</span> _phr<span class="br0">&#40;</span><span class="st0">'Сейчас я дам тебе по роже!'</span><span class="sy0">,</span> 
                           <span class="st0">'-- Ну все... Мощные руки выталкивают меня в коридор...'</span><span class="sy0">,</span>
			<span class="co2">[[poff(4)]]</span><span class="br0">&#41;</span><span class="sy0">,</span>
		<span class="br0">&#91;</span><span class="nu0">4</span><span class="br0">&#93;</span> <span class="sy0">=</span> _phr<span class="br0">&#40;</span><span class="st0">'Ты, кабан! Я же тебе сказал -- у меня есть приглашение!'</span><span class="sy0">,</span>
			<span class="co2">[[-- Чтоооооо? Глаза охранника наливаются кровью... 
                        Мощный пинок отправляет меня в коридор...]]</span><span class="sy0">,</span>
			<span class="co2">[[poff(3)]]</span><span class="br0">&#41;</span><span class="sy0">,</span>
	<span class="br0">&#125;</span><span class="sy0">;</span>
	<span class="kw3">exit</span> <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="sy0">,</span>w<span class="br0">&#41;</span>
		s<span class="sy0">:</span>pon<span class="br0">&#40;</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy0">;</span>
	<span class="kw1">end</span><span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre>

<p>
<code>_phr</code> – создает выключенную фразу, которую можно включить. Данный пример показывает также возможность использования методов <code>pon</code>, <code>poff</code>, <code>prem</code> для диалога (см. <code>exit</code>).
</p>

</div>
<!-- EDIT21 SECTION "Простые диалоги" [124814-130450] -->
<h1 class="sectionedit22" id="облегченные_объекты">15. Облегченные объекты</h1>
<div class="level1">

<p>
Иногда сцену нужно наполнить декорациями, которые обладают ограниченной функциональностью, но делают игру разнообразней. Или вы хотите сделать что-то вроде кнопки «дальше». 
Для таких вещей можно использовать облегченный объект. Например:
</p>
<pre class="code lua">sside <span class="sy0">=</span> room <span class="br0">&#123;</span>
	nam <span class="sy0">=</span> <span class="st0">'Южная сторона'</span><span class="sy0">;</span>
	dsc <span class="sy0">=</span> <span class="co2">[[Я нахожусь у южной стены здания института. ]]</span><span class="sy0">;</span>
	act <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="sy0">,</span> w<span class="br0">&#41;</span>
		<span class="kw1">if</span> w <span class="sy0">==</span> <span class="st0">&quot;подъезд&quot;</span> <span class="kw1">then</span>
			ways<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">:</span>add<span class="br0">&#40;</span><span class="st0">'stolcorridor'</span><span class="br0">&#41;</span><span class="sy0">;</span>
			p <span class="co2">[[Я подошел к подъезду. На двери подъезда надпись -- 
                            'Столовая'. Хм -- зайти внутрь?]]</span><span class="sy0">;</span>
		<span class="kw1">elseif</span> w <span class="sy0">==</span> <span class="st0">&quot;люди&quot;</span> <span class="kw1">then</span>
			p <span class="st0">'Те, кто выходят, выглядят более довольными...'</span><span class="sy0">;</span>
		<span class="kw1">end</span>
	<span class="kw1">end</span><span class="sy0">;</span>
	obj <span class="sy0">=</span> <span class="br0">&#123;</span> vobj<span class="br0">&#40;</span><span class="st0">&quot;подъезд&quot;</span><span class="sy0">,</span> <span class="st0">&quot;У восточного угла находится небольшой {подъезд}.&quot;</span><span class="br0">&#41;</span><span class="sy0">,</span>
		vobj<span class="br0">&#40;</span><span class="st0">&quot;люди&quot;</span><span class="sy0">,</span> <span class="co2">[[Время от времени дверь подъезда хлопает 
                                впуская и выпуская {людей}.]]</span><span class="br0">&#41;</span><span class="br0">&#125;</span><span class="sy0">,</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre>

<p>
Как видим, <code>vobj</code> позволяет сделать легкую версию статического объекта, с которым, тем не менее, можно взаимодействовать (за счет определения обработчика <code>act</code> в сцене и анализа имени объекта). <code>vobj</code> также вызывает метод <code>used</code>, при этом в качестве третьего параметра передается объект, воздействующий на виртуальный объект. Если вы используете предмет на <code>vobj</code>, то как и с обычными объектами, у предмета инвентаря вызовется <code>use</code>. Но объекты <code>vobj</code> обычно не имеют дескриптора, поэтому, для определения страдательного объекта можно воспользоваться <code>stead.nameof</code>.
</p>
<pre class="code lua">use <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="sy0">,</span> w<span class="br0">&#41;</span>
        <span class="kw1">if</span> stead<span class="sy0">.</span>nameof<span class="br0">&#40;</span>w<span class="br0">&#41;</span> <span class="sy0">==</span> <span class="st0">&quot;люди&quot;</span> <span class="kw1">then</span>
                p <span class="st0">&quot;Не стоит беспокоить людей.&quot;</span>
                <span class="kw1">return</span>
        <span class="kw1">end</span>
<span class="kw1">end</span><span class="sy0">;</span></pre>

<p>
Синтаксис <code>vobj</code> прост: <code>vobj(имя, описатель)</code>; <code>vobj</code> можно добавлять в сцену динамически, например:
</p>
<pre class="code lua">put<span class="br0">&#40;</span>vobj<span class="br0">&#40;</span><span class="st0">&quot;дальше&quot;</span><span class="sy0">,</span> <span class="st0">&quot;{Дальше}&quot;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Хотя я не рекомендую этот стиль, он больше характерен для старых версий движка. Нагляднее использовать <code>disable/enable</code>;
</p>
<pre class="code lua"><span class="sy0">...</span>
exist <span class="st0">'дальше'</span><span class="sy0">:</span>enable<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="sy0">...</span>
obj <span class="sy0">=</span> <span class="br0">&#123;</span> vobj<span class="br0">&#40;</span><span class="st0">&quot;дальше&quot;</span><span class="sy0">,</span> <span class="st0">&quot;{Дальше}&quot;</span><span class="br0">&#41;</span><span class="sy0">:</span>disable<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#125;</span><span class="sy0">;</span></pre>

<p>
Существует модификация объекта <code>vobj</code> – <code>vway</code>. <code>vway</code> реализует ссылку-переход. 
Синтаксис <code>vway</code>: <code>vway(имя, описатель, сцена назначения);</code> например:
</p>
<pre class="code lua">	obj <span class="sy0">=</span> <span class="br0">&#123;</span> vway<span class="br0">&#40;</span><span class="st0">&quot;дальше&quot;</span><span class="sy0">,</span> <span class="st0">&quot;Нажмите {здесь}.&quot;</span><span class="sy0">,</span> <span class="st0">'nextroom'</span><span class="br0">&#41;</span> <span class="br0">&#125;</span><span class="sy0">;</span> 
        <span class="co1">-- при нажатии - перейдем в nextroom</span></pre>
<div class="wrap_center wrap_round wrap_info plugin_wrap">
<p>
На самом деле, если вы пишите что-то вроде книги-игры, где игровой процесс представляет из себя переход по ссылкам, то (если не считать, что это неудачная идея для вашей первой игры) вам следует воспользоваться модулем «xact», в котором реализован более простой механизм создания ссылок.
</p>
</div>
<p>
Вы можете динамически заполнять сцену объектами <code>vway</code> (аналогично <code>vobj</code>). Например:
</p>
<pre class="code lua">	put<span class="br0">&#40;</span>vway<span class="br0">&#40;</span><span class="st0">&quot;next&quot;</span><span class="sy0">,</span> <span class="st0">&quot;{Дальше}.&quot;</span><span class="sy0">,</span> <span class="st0">'next_room'</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="co1">-- другой способ, явно вызывая метод списка</span>
        objs<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">:</span>add<span class="br0">&#40;</span>vway<span class="br0">&#40;</span><span class="st0">&quot;next&quot;</span><span class="sy0">,</span> <span class="st0">&quot;{Дальше}.&quot;</span><span class="sy0">,</span> <span class="st0">'next_room'</span><span class="br0">&#41;</span><span class="br0">&#41;</span></pre>

<p>
Следует понимать, что и <code>vobj</code> и <code>vway</code> это обычные объекты, с заранее определенными обработчиками и функциями сохранения (что позволяет создавать эти объекты на лету, как показано в примерах выше). Когда вы узнаете архитектуру движка INSTEAD, вы сможете писать свои варианты объектов с требуемыми свойствами.
</p>

<p>
Говоря об облегченных объектах, хотелось бы обратить внимание еще на один способ описания декораций. Если объект в сцене является статическим, то его можно определить непосредственно в <code>obj</code>, без присваивания дескриптора. Например:
</p>
<pre class="code lua">hall <span class="sy0">=</span> room <span class="br0">&#123;</span>
       nam <span class="sy0">=</span> <span class="st0">'Гостинная'</span><span class="sy0">;</span>
       dsc <span class="sy0">=</span> <span class="co2">[[Я в просторной гостинной.]]</span><span class="sy0">;</span>
       obj <span class="sy0">=</span> <span class="br0">&#123;</span>
               obj <span class="br0">&#123;</span>
                       nam <span class="sy0">=</span> <span class="st0">'стол'</span><span class="sy0">;</span>
                       dsc <span class="sy0">=</span> <span class="co2">[[Посреди гостинной находится {стол}.]]</span><span class="sy0">;</span>
                       act <span class="sy0">=</span> <span class="co2">[[Из красного дерева.]]</span><span class="sy0">;</span>
               <span class="br0">&#125;</span><span class="sy0">;</span>
       <span class="br0">&#125;</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>

<p>
В обработчике <code>use</code> вы можете идентифицировать такие объекты также, как и <code>vobj</code>:
</p>
<pre class="code lua">use <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="sy0">,</span> w<span class="br0">&#41;</span>
        <span class="kw1">if</span> stead<span class="sy0">.</span>nameof<span class="br0">&#40;</span>w<span class="br0">&#41;</span> <span class="sy0">==</span> <span class="st0">'стол'</span> <span class="kw1">then</span>
                p <span class="co2">[[Не хочется портить красивую вещь.]]</span>
                <span class="kw1">return</span>
        <span class="kw1">end</span>
<span class="kw1">end</span></pre>

<p>
Использовать или нет такую форму решать вам, многие считают, что присвоение дескриптора всем объектам делает код более понятным. Я в своих играх использую оба подхода.
</p>

<p>
Наконец, еще один способ для создания декораций, это использование одного и того-же объекта в разных сценах. Например, можно создать объект «гильзы дробовика», и выбрасывать его на сцену всегда, когда герой стреляет. Понятно, что в таком случае, гильзы могут служить только в качестве декораций, их нельзя будет взять и вообще произвести какое-то действие, меняющее состояние.
</p>

</div>
<!-- EDIT22 SECTION "15. Облегченные объекты" [130451-137653] -->
<h1 class="sectionedit23" id="динамические_события">16. Динамические события</h1>
<div class="level1">

<p>
Вы можете определять обработчики, которые выполняются каждый раз, когда время игры увеличивается на 1. Обычно, это имеет смысл для живых персонажей, или каких-то фоновых процессов игры. Алгоритм шага игры выглядит примерно так:
</p>
<ol>
<li class="level1"><div class="li"> Игрок нажимает на ссылку;</div>
</li>
<li class="level1"><div class="li"> Реакция <code>act</code>, <code>use</code>, <code>inv</code>, осмотр сцены (клик по названию сцены) или переход в другую сцену;</div>
</li>
<li class="level1"><div class="li"> Динамические события;</div>
</li>
<li class="level1"><div class="li"> Вывод состояния сцены (если нужно статическая часть, и всегда – динамическая).</div>
</li>
</ol>

<p>
Например, сделаем Барсика живым:
</p>
<pre class="code lua">mycat <span class="sy0">=</span> obj <span class="br0">&#123;</span>
	nam <span class="sy0">=</span> <span class="st0">'Барсик'</span><span class="sy0">;</span>
	lf <span class="sy0">=</span> <span class="br0">&#123;</span>
		<span class="br0">&#91;</span><span class="nu0">1</span><span class="br0">&#93;</span> <span class="sy0">=</span> <span class="st0">'Барсик шевелится у меня за пазухой.'</span><span class="sy0">,</span>
		<span class="br0">&#91;</span><span class="nu0">2</span><span class="br0">&#93;</span> <span class="sy0">=</span> <span class="st0">'Барсик выглядывает из-за пазухи.'</span><span class="sy0">,</span>
		<span class="br0">&#91;</span><span class="nu0">3</span><span class="br0">&#93;</span> <span class="sy0">=</span> <span class="st0">'Барсик мурлычит у меня за пазухой.'</span><span class="sy0">,</span>
		<span class="br0">&#91;</span><span class="nu0">4</span><span class="br0">&#93;</span> <span class="sy0">=</span> <span class="st0">'Барсик дрожит у меня за пазухой.'</span><span class="sy0">,</span>
		<span class="br0">&#91;</span><span class="nu0">5</span><span class="br0">&#93;</span> <span class="sy0">=</span> <span class="st0">'Я чувствую тепло Барсика у себя за пазухой.'</span><span class="sy0">,</span>
		<span class="br0">&#91;</span><span class="nu0">6</span><span class="br0">&#93;</span> <span class="sy0">=</span> <span class="st0">'Барсик высовывает голову из-за пазухи и осматривает местность.'</span><span class="sy0">,</span>
	<span class="br0">&#125;</span><span class="sy0">;</span>
	life <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="br0">&#41;</span>
		<span class="kw1">local</span> r <span class="sy0">=</span> rnd<span class="br0">&#40;</span><span class="nu0">5</span><span class="br0">&#41;</span><span class="sy0">;</span>
		<span class="kw1">if</span> r <span class="sy0">&gt;</span> <span class="nu0">2</span> <span class="kw1">then</span> <span class="co1">-- делать это не всегда</span>
			<span class="kw1">return</span><span class="sy0">;</span>
		<span class="kw1">end</span>
		r <span class="sy0">=</span> rnd<span class="br0">&#40;</span><span class="sy0">#</span>s<span class="sy0">.</span>lf<span class="br0">&#41;</span><span class="sy0">;</span> <span class="co1">-- символ # -- число элементов в массиве</span>
		p<span class="br0">&#40;</span>s<span class="sy0">.</span>lf<span class="br0">&#91;</span>r<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy0">;</span> <span class="co1">-- выводим одно из 6 состояний Барсика</span>
	<span class="kw1">end</span><span class="sy0">;</span>
<span class="sy0">....</span>
<span class="co1">-- и вот момент в игре, когда Барсик попадает к нам за пазуху!</span>
take <span class="st0">'mycat'</span> <span class="co1">-- добавить в инвентарь</span>
lifeon <span class="st0">'mycat'</span> <span class="co1">-- оживить Барсика!</span>
<span class="sy0">....</span></pre>

<p>
Любой объект (в том числе и сцена) могут иметь свой обработчик <code>life</code>, который вызывается каждый такт игры, если объект был добавлен в список живых объектов с помощью <code>lifeon</code>. Не забывайте удалять живые объекты из списка с помощью <code>lifeoff</code>, когда они больше не нужны. Это можно сделать, например, в обработчике <code>left</code>, или любым другим способом. 
</p>
<div class="wrap_center wrap_round wrap_info plugin_wrap">
<p>
Если в вашей игре много «живых» объектов, вы можете задавать им приоритеты. Для этого, воспользуйтесь вторым числовым параметром (целое неотрицательное число) <code>lifeon</code>, чем меньше число, тем выше приоритет. 1 – самый высокий.
</p>
</div>
<p>
Если вам нужен фоновый процесс в какой-то комнате, запускайте его в <code>entered</code> и удаляйте в <code>left</code>, например:
</p>
<pre class="code lua">podval <span class="sy0">=</span> room <span class="br0">&#123;</span>
        nam  <span class="sy0">=</span> <span class="st0">'В подвале'</span><span class="sy0">;</span>
        dsc <span class="sy0">=</span> <span class="co2">[[Тут темно!]]</span><span class="sy0">;</span>
        entered <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="br0">&#41;</span>
                lifeon<span class="br0">&#40;</span>s<span class="br0">&#41;</span><span class="sy0">;</span>
        <span class="kw1">end</span><span class="sy0">;</span>
        left <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="br0">&#41;</span>
                lifeoff<span class="br0">&#40;</span>s<span class="br0">&#41;</span><span class="sy0">;</span>
        <span class="kw1">end</span><span class="sy0">;</span>
        life <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="br0">&#41;</span>
                <span class="kw1">if</span> rnd<span class="br0">&#40;</span><span class="nu0">10</span><span class="br0">&#41;</span> <span class="sy0">&gt;</span> <span class="nu0">8</span> <span class="kw1">then</span>
                        p <span class="co2">[[Я слышу какие-то шорохи!]]</span><span class="sy0">;</span> 
                        <span class="co1">-- изредка пугать игрока шорохами</span>
                <span class="kw1">end</span>
        <span class="kw1">end</span><span class="sy0">;</span>
        way <span class="sy0">=</span>  <span class="br0">&#123;</span> <span class="st0">'upstair'</span> <span class="br0">&#125;</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>

<p>
Если вам нужно определить, был ли переход игрока из одной сцены в другую, воспользуйтесь <code>player_moved</code>.
</p>
<pre class="code lua">flash <span class="sy0">=</span> obj <span class="br0">&#123;</span>
        nam  <span class="sy0">=</span> <span class="st0">'фонарик'</span><span class="sy0">;</span>
        var <span class="br0">&#123;</span> on <span class="sy0">=</span> <span class="kw4">false</span> <span class="br0">&#125;</span><span class="sy0">;</span>
        life <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="br0">&#41;</span>
                <span class="kw1">if</span> player_moved<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="kw1">then</span> <span class="co1">-- гасить фонарик при переходах</span>
                        s<span class="sy0">.</span>on <span class="sy0">=</span> <span class="kw4">false</span>
                        p <span class="st0">&quot;Я выключил фонарик.&quot;</span>
                        <span class="kw1">return</span>
                <span class="kw1">end</span>
        <span class="kw1">end</span><span class="sy0">;</span>
<span class="sy0">...</span>
<span class="br0">&#125;</span></pre>

<p>
Для отслеживания протекающих во времени событий, используйте <code>time()</code> или вспомогательную переменную-счетчик. Для определения местоположения игрока – <code>here()</code>. Для определения факта, что объект «живой» – <code>live()</code>.
</p>
<pre class="code lua">dynamite <span class="sy0">=</span> obj <span class="br0">&#123;</span>
        nam  <span class="sy0">=</span> <span class="st0">'динамит'</span><span class="sy0">;</span>
        var <span class="br0">&#123;</span> 
                timer <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> 
        <span class="br0">&#125;</span><span class="sy0">;</span>                
        used <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="sy0">,</span> w<span class="br0">&#41;</span>
                <span class="kw1">if</span> w <span class="sy0">==</span> fire <span class="kw1">then</span>
                        <span class="kw1">if</span> live<span class="br0">&#40;</span>s<span class="br0">&#41;</span> <span class="kw1">then</span>
                                <span class="kw1">return</span> <span class="st0">&quot;Уже горит!&quot;</span>
                        <span class="kw1">end</span>
                        p <span class="st0">&quot;Я поджег динамит.&quot;</span>
                        lifeon<span class="br0">&#40;</span>s<span class="br0">&#41;</span>
                <span class="kw1">end</span>
        <span class="kw1">end</span><span class="sy0">;</span>
        life <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="br0">&#41;</span>
                s<span class="sy0">.</span>timer <span class="sy0">=</span> s<span class="sy0">.</span>timer <span class="sy0">+</span> <span class="nu0">1</span>
                <span class="kw1">if</span> s<span class="sy0">.</span>timer <span class="sy0">==</span> <span class="nu0">5</span> <span class="kw1">then</span>
                        lifeoff<span class="br0">&#40;</span>s<span class="br0">&#41;</span>
                        <span class="kw1">if</span> here<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy0">==</span> where<span class="br0">&#40;</span>s<span class="br0">&#41;</span> <span class="kw1">then</span>
                                p <span class="co2">[[Динамит взорвался рядом со мной!]]</span>
                        <span class="kw1">else</span>
                                p <span class="co2">[[Я услышал, как взорвался динамит.]]</span><span class="sy0">;</span>
                        <span class="kw1">end</span>
                <span class="kw1">end</span>
        <span class="kw1">end</span><span class="sy0">;</span>
<span class="sy0">...</span>
<span class="br0">&#125;</span></pre>

<p>
Если <code>life</code> обработчик возвращает текст события, он печатается после описания сцены.
</p>

<p>
Вы можете вернуть из обработчика <code>life</code> второй код возврата, важность. (<code>true</code> или <code>false</code>). Например:
</p>
<pre class="code lua">    p <span class="st0">'В комнату вошел охранник.'</span>
    <span class="kw1">return</span> <span class="kw4">true</span></pre>

<p>
Или:
</p>
<pre class="code lua">    <span class="kw1">return</span> <span class="st0">'В комнату вошел охранник.'</span><span class="sy0">,</span> <span class="kw4">true</span></pre>

<p>
При этом текст события будет выведен <em>до</em> описания объектов. 
</p>

<p>
Если вы хотите блокировать <code>life</code> обработчики в какой-то из комнат, воспользуйтесь модулем <code>nolife</code>. Например:
</p>
<pre class="code lua">instead_version <span class="st0">&quot;1.8.2&quot;</span>
<span class="kw3">require</span> <span class="st0">&quot;hideinv&quot;</span>
<span class="kw3">require</span> <span class="st0">&quot;nolife&quot;</span>
&nbsp;
guarddlg <span class="sy0">=</span> dlg <span class="br0">&#123;</span>
        nam <span class="sy0">=</span> <span class="st0">'Охранник'</span><span class="sy0">;</span>
        hideinv <span class="sy0">=</span> <span class="kw4">true</span><span class="sy0">;</span>
        nolife <span class="sy0">=</span> <span class="kw4">true</span><span class="sy0">;</span>
<span class="sy0">...</span>
<span class="br0">&#125;</span></pre>

<p>
Отдельно стоит рассмотреть вопрос перехода игрока из <code>life</code> обработчика. Если вы собираетесь использовать функции <code>walk…</code> внутри <code>life</code>, то вам следует учитывать следующее поведение.
</p>

<p>
Если <code>life</code> переносит игрока в новую локацию, то подавляется весь вывод, который произведен <code>life</code> обработчиками объектов с прошлой сцены (то есть, все предыдущие <code>life</code> выводы). Остается только вывод <code>life</code> обработчиков, сработавших после перехода. Это сделано специально, так как вывод прошлых <code>life</code> относился к прошлой сцене, например:
</p>
<ol>
<li class="level1"><div class="li"> <code>life</code> сцены <code>скала</code> вывел текст о том, что герою страшно, когда он висит на тросе;</div>
</li>
<li class="level1"><div class="li"> <code>life</code> объекта <code>трос</code> вывел текст о том, что трос оборвался и герой упал вниз и сделал <code>walk</code> в новую локацию <code>море</code>;</div>
</li>
</ol>

<p>
Здесь <code>life1</code> выполнялся в ином контексте и его вывод подавляется.
</p>

<p>
Кроме всего прочего, обработчик <code>life</code> может влиять на текст реакций действий игрока, которые произошли в этом игровом такте. Например, рассмотрим такую ситуацию:
</p>
<ol>
<li class="level1"><div class="li"> Игрок осмотрел окно («Я выглянул в окно. Унылый пейзаж.»);</div>
</li>
<li class="level1"><div class="li"> <code>life</code> обработчик <code>гоблин</code> сообщил, что внезапно дверь открылась и в комнату влетел гоблин;</div>
</li>
</ol>

<p>
Автору игры может показаться, что информация о пейзаже, когда перед игроком стоит свирепый гоблин, неуместна. Тогда он пишет в <code>life</code> обработчике:
</p>
<pre class="code lua">        p <span class="co2">[[Свирепый гоблин влетел в комнату!]]</span><span class="sy0">;</span>
        ACTION_TEXT <span class="sy0">=</span> <span class="kw4">nil</span> 
        <span class="co1">-- текст реакции пуст (раньше он был равен </span>
        <span class="co1">-- &quot;Я выглянул в окно. Унылый пейзаж.&quot;)</span></pre>

<p>
Таким образом, <code>ACTION_TEXT</code> это текстовая переменная, доступная в <code>life</code> обработчике для модификации. Обычно, имеет смысл или не трогать ее, или обнулять, как в примере выше.
</p>

</div>
<!-- EDIT23 SECTION "16. Динамические события" [137654-147181] -->
<h1 class="sectionedit24" id="графика">17. Графика</h1>
<div class="level1">

<p>
Графический интерпретатор INSTEAD анализирует атрибут сцены <code>pic</code>, и воспринимает его как путь к картинке, например:
</p>
<pre class="code lua">home <span class="sy0">=</span> room <span class="br0">&#123;</span>
	pic <span class="sy0">=</span> <span class="st0">'gfx/home.png'</span><span class="sy0">;</span>
	nam <span class="sy0">=</span> <span class="st0">'Дома'</span><span class="sy0">;</span>
	dsc <span class="sy0">=</span> <span class="st0">'Я у себя дома'</span><span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre>
<div class="wrap_center wrap_round wrap_important plugin_wrap">
<p>
<em class="u">Важно!</em>
</p>

<p>
Используйте в путях только прямые &#039;/&#039;. Также, настоятельно рекомендуется использовать в именах каталогов и файлов только латинские строчные символы. Этим самым вы обезопасите свою игру от проблем с совместимостью и она будет работать на всех архитектурных платформах, куда портирован INSTEAD.
</p>
</div>
<p>
Конечно, <code>pic</code> может быть функцией, расширяя возможности разработчика.
Если в текущей сцене не определен атрибут <code>pic</code>, то берется атрибут <code>game.pic</code>. Если не определен и он, то картинка не отображается.
</p>

<p>
Поддерживаются все наиболее распространенные форматы изображений, но я рекомендую вам использовать <code>png</code> и (когда важен размер) <code>jpg</code>.
</p>

<p>
Вы можете использовать в качестве картинок анимированные gif файлы.
</p>

<p>
Вы можете встраивать графические изображения прямо в текст, в том числе в инвентарь, переходы, заглавия комнат и <code>dsc</code>  с помощью функции <code>img</code>. Например:
</p>
<pre class="code lua">apple <span class="sy0">=</span> obj <span class="br0">&#123;</span>
        <span class="co1">-- склеить текстовую строку с изображением</span>
        nam <span class="sy0">=</span> <span class="st0">'яблоко '</span><span class="sy0">..</span>img <span class="br0">&#40;</span><span class="st0">'img/apple.png'</span><span class="br0">&#41;</span><span class="sy0">;</span> 
<span class="br0">&#125;</span></pre>

<p>
Хотя, в данном случае предпочтительнее воспользоваться <code>disp</code>:
</p>
<pre class="code lua">apple <span class="sy0">=</span> obj <span class="br0">&#123;</span>
        nam <span class="sy0">=</span> <span class="st0">'яблоко'</span><span class="sy0">;</span>
        disp <span class="sy0">=</span> <span class="st0">'яблоко '</span> <span class="sy0">..</span>img<span class="br0">&#40;</span><span class="st0">'img/apple.png'</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>

<p>
Теперь мы разделили имя объекта и его отображение.
</p>

<p>
Тем-не менее, картинку сцены всегда следует оформлять в виде <code>pic</code> атрибута, а не вставки <code>img</code> в <code>dsc</code> комнаты.
</p>

<p>
Дело в том, что картинка сцены масштабируется по другому алгоритму. Картинки <code>img</code> масштабируются в соответствии с настройками INSTEAD (масштаб темы), а <code>pic</code> – учитывает также размер картинки.
</p>

<p>
Кроме того, картинки <code>pic</code> обладают и другими свойствами, например, возможностью отслеживания координат кликов мышью.
</p>

<p>
Если вы поместите <code>img</code> внутрь { и }, то получите графическую ссылку.
</p>
<pre class="code lua">apple <span class="sy0">=</span> obj <span class="br0">&#123;</span>
	nam <span class="sy0">=</span> <span class="st0">'яблоко'</span><span class="sy0">;</span>
        disp <span class="sy0">=</span> <span class="st0">'яблоко '</span> <span class="sy0">..</span>img<span class="br0">&#40;</span><span class="st0">'img/apple.png'</span><span class="br0">&#41;</span><span class="sy0">;</span>
        dsc <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="br0">&#41;</span>
                p <span class="br0">&#40;</span><span class="st0">&quot;На полу лежит {яблоко&quot;</span><span class="sy0">,</span> 
                       img <span class="st0">'img/apple.png'</span><span class="sy0">,</span> 
                        <span class="st0">&quot;}&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>                
                <span class="co1">-- другие варианты:</span>
                <span class="co1">-- return &quot;На полу лежит {яблоко&quot;..img('img/apple.png')..&quot;}&quot;;</span>
                <span class="co1">-- p &quot;На полу лежит {яблоко&quot;..img('img/apple.png')..&quot;}&quot;;</span>
                <span class="co1">-- или dsc = &quot;На полу лежит {яблоко&quot;..img('img/apple.png')..&quot;}&quot;;</span>
        <span class="kw1">end</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>

<p>
INSTEAD поддерживает обтекание картинок текстом. Если картинка вставляется с помощью функции <code>imgl</code>/<code>imgr</code>, она будет расположена у левого/правого края. 
</p>
<div class="wrap_center wrap_round wrap_important plugin_wrap">
<p>
<em class="u">Важно!</em>
</p>

<p>
Картинки, вставленные в текст с помощью <code>imgl/imgr</code> не могут быть ссылками!!! Используйте их только в декоративных целях.
</p>
</div>
<p>
Для задания отступов вокруг изображения используйте <code>pad</code>, например:
</p>
<pre class="code lua">imgl <span class="st0">'pad:16,picture.png'</span> <span class="co1">-- отступы по 16 от каждого края</span>
imgl <span class="st0">'pad:0 16 16 4,picture.png'</span> <span class="co1">-- отступы: вверху 0, справа 16, внизу 16, слева 4</span>
imgl <span class="st0">'pad:0 16,picture.png'</span> <span class="co1">-- отступы: вверху 0, справа 16, внизу 0, слева 16</span></pre>

<p>
Вы можете использовать псевдо-файлы для изображений прямоугольников и пустых областей:
</p>
<pre class="code lua">dsc <span class="sy0">=</span> img <span class="st0">'blank:32x32'</span><span class="sy0">..</span><span class="co2">[[Строка с пустым изображением.]]</span><span class="sy0">;</span>
dsc <span class="sy0">=</span> img <span class="st0">'box:32x32,red,128'</span><span class="sy0">..</span><span class="co2">[[Строка красным полупрозрачным квадратом.]]</span><span class="sy0">;</span></pre>

<p>
INSTEAD может обрабатывать составные картинки, например:
</p>
<pre class="code lua">pic <span class="sy0">=</span> <span class="st0">'gfx/mycat.png;gfx/milk.png@120,25;gfx/fish.png@32,32'</span><span class="sy0">;</span></pre>

<p>
Таким образом, составная картинка представляет собой набор путей к изображениям, разделенных символом <code>;</code>. Вторая и последующие компоненты могут содержать постфикс в виде @x_координата,y_координата, где координате 0,0 соответствует левый верхний угол всего изображения. Общий размер картинки считается равным общему размеру первой компоненте составной картинки, то есть, первый компонент (в нашем примере – gfx/mycat.png) играет роль холста, а последующие компоненты накладываются на этот холст.
</p>

<p>
Наложение происходит для левого верхнего угла накладываемой картинки. Если вам нужно, чтобы наложение происходило относительно центра накладываемой картинки, используйте перед координатами префикс <code>c</code>, например:
</p>
<pre class="code lua">pic <span class="sy0">=</span> <span class="st0">'gfx/galaxy.png;gfx/star.png@c128,132'</span><span class="sy0">;</span></pre>

<p>
Оформив в виде функции формирование пути составной картинки, вы можете генерировать изображение на основе игрового состояния.
</p>
<div class="wrap_center wrap_round wrap_info plugin_wrap">
<p>
Если вы в своей игре привязываетесь к каким-то координатам изображений, или к их размерам, делайте это относительно оригинальных размеров изображений. При масштабировании темы под заданное игроком разрешение, INSTEAD сам будет осуществлять пересчёт координат (при этом координаты для игры выглядят так, как будто игра запущена без масштабирования). Однако, возможны небольшие погрешности вычислений.
</p>
</div>
<p>
Если вам не хватает функций, описанных в этой главе, изучите модуль «sprites», который предоставляет более широкие возможности по графическому оформлению. Но я крайне не рекомендую делать это в своей первой игре.
</p>

</div>
<!-- EDIT24 SECTION "17. Графика" [147182-155438] -->
<h1 class="sectionedit25" id="музыка">18. Музыка</h1>
<div class="level1">

<p>
Интерпретатор проигрывает в цикле текущую музыку, которая задается с помощью функции:
<code>set_music(путь к музыкальному файлу)</code>.
</p>
<div class="wrap_center wrap_round wrap_important plugin_wrap">
<p>
<em class="u">Важно!</em>
</p>

<p>
Используйте в путях только прямые &#039;/&#039;. Также, настоятельно рекомендуется использовать в именах каталогов и файлов только латинские строчные символы. Этим самым вы обезопасите свою игру от проблем с совместимостью и она будет работать на всех архитектурных платформах, куда портирован INSTEAD.
</p>
</div>
<p>
Поддерживается большинство музыкальных форматов, но настоятельно рекомендуется использовать формат <code>ogg</code>, так как именно он поддерживается наилучшим образом во всех версиях INSTEAD (для различных платформ).
</p>
<div class="wrap_center wrap_round wrap_important plugin_wrap">
<p>
<em class="u">Важно!</em>
</p>

<p>
Следует проявлять осторожность при использовании трекерной музыки, так как в некоторых дистрибутивах Linux могут быть проблемы при проигрывании определенных файлов (ошибки в связке библиотек SDL_mixer и libmikmod).
</p>

<p>
Также, если вы используете <code>mid</code> файлы, будьте готовы к тому, что игрок услышит их только в Windows версии INSTEAD (так как в большинстве случаев, Unix версии SDL_mixer собраны без поддержки <code>timidity</code>).
</p>
</div>
<p>
Например:
</p>
<pre class="code lua">street <span class="sy0">=</span> room <span class="br0">&#123;</span>
	pic <span class="sy0">=</span> <span class="st0">'gfx/street.png'</span><span class="sy0">;</span>
	enter <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span><span class="br0">&#41;</span>
		set_music<span class="br0">&#40;</span><span class="st0">'mus/rain.ogg'</span><span class="br0">&#41;</span>
	<span class="kw1">end</span><span class="sy0">;</span>
	nam <span class="sy0">=</span> <span class="st0">'на улице'</span><span class="sy0">;</span>
	dsc <span class="sy0">=</span> <span class="st0">'На улице идет дождь.'</span><span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre>

<p>
<code>get_music()</code> возвращает текущее имя трека.
</p>

<p>
В функцию <code>set_music()</code> можно передавать второй параметр – количество проигрываний (циклов). Получить текущий  счетчик можно с помощью <code>get_music_loop</code>. 0 – означает вечный цикл. 1..n – количество проигрываний. -1 – проигрывание текущего трека закончено. 
</p>

<p>
Часто бывает необходимым сменить музыку на время, а затем восстановить предыдущий трек. Для этого можно воспользоваться функциями <code>save_music()/restore_music()</code>. Эта пара функций запоминает/восстанавливает трек в/из переменных объекта текущего контекста. Например, для обработчиков <code>enter/exit/entered/left</code> это будет текущая комната.
</p>

<p>
Если вы хотите явно задать объект, в котором будет сохранено состояние (из которого будет восстановлено состояние) трека, укажите его в качестве необязательного параметра. Данные функции не работают с ссылками, поэтому вы не можете передавать в них текстовые строки-указатели на объекты.
</p>

<p>
Например:
</p>
<pre class="code lua">street <span class="sy0">=</span> room <span class="br0">&#123;</span>
	pic <span class="sy0">=</span> <span class="st0">'gfx/street.png'</span><span class="sy0">;</span>
	entered <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span><span class="br0">&#41;</span>
                save_music<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
		set_music<span class="br0">&#40;</span><span class="st0">'mus/rain.ogg'</span><span class="br0">&#41;</span>
	<span class="kw1">end</span><span class="sy0">;</span>
        left <span class="sy0">=</span> restore_music<span class="sy0">;</span>
	nam <span class="sy0">=</span> <span class="st0">'на улице'</span><span class="sy0">;</span>
	dsc <span class="sy0">=</span> <span class="st0">'На улице идет дождь.'</span><span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre>

<p>
Обратите внимание, что в примере <code>left</code> обработчику присваивается значение <code>restore_music</code>. Отсутствие () после <code>restore_music</code> означает, что это присваивание самого кода функции, а не ее вызов. Таким образом, при вызове обработчика <code>left</code>, будет вызвана <code>restore_music</code> с параметром равным <code>street</code>, что нам и требуется. Впрочем, можно было написать и такой код:
</p>
<pre class="code lua">        left <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span><span class="br0">&#41;</span>
                restore_music<span class="br0">&#40;</span><span class="br0">&#41;</span>
        <span class="kw1">end</span><span class="sy0">;</span></pre>

<p>
Или:
</p>
<pre class="code lua">        restore_music<span class="br0">&#40;</span>street<span class="br0">&#41;</span></pre>

<p>
Для того, чтобы отменить проигрывание музыки, вы можете использовать <code>stop_music()</code>
Функция <code>is_music()</code> позволяет узнать, проигрывается ли музыка в данный момент.
</p>

<p>
Для проигрывания звуков используйте <code>set_sound()</code>. Настоятельно рекомендуется использовать формат <code>ogg</code>, хотя большинство распространенных звуковых форматов также будет работать.
</p>

<p>
Различие между музыкой и звуковым файлом заключается в том, что движок следит за процессом проигрывания музыки и сохраняет/восстанавливает текущий проигрываемый трек. Выйдя из игры и загрузив ее снова, игрок услышит то же музыкальное оформление, что слышал при выходе. Звуки обычно означают кратковременные эффекты, и движок не сохраняет и не восстанавливает звуковые события. Так, если игрок не успел дослушать звук выстрела и вышел из игры, после загрузки файла сохранения он не
услышит звук (или его окончание) снова.
</p>

<p>
Тем не менее, если учесть то, что <code>set_sound</code> позволяет запускать зацикленные звуки, то различие между музыкой и звуками становится уже не таким однозначным.
</p>

<p>
Итак, определение функции: <code>set_sound(файл, [канал], [цикл])</code>, где:
</p>
<ul>
<li class="level1"><div class="li"> файл – путь и\или имя звукового файла;</div>
</li>
<li class="level1"><div class="li"> канал – номер канала [0..7]; Если не указан, то выберется первый свободный.</div>
</li>
<li class="level1"><div class="li"> цикл – количество проигрываний 1..n, 0 – зацикливание.</div>
</li>
</ul>

<p>
Для остановки проигрывания звука можно использовать <code>stop_sound()</code> Для остановки звука в определенном канале <code>stop_sound(канал)</code>.
</p>
<div class="wrap_center wrap_round wrap_info plugin_wrap">
<p>
На самом деле, <code>set_sound</code> имеет одну особенность. Если вы вызовете эту функцию подряд несколько раз, то эффект принесет только последний вызов. Если вам нужно запускать несколько одновременных звуков за один такт игры, используйте <code>add_sound()</code>. Параметры к функции имеют тот же смысл, что и у <code>set_sound()</code>.
</p>
</div><div class="wrap_center wrap_round wrap_important plugin_wrap">
<p>
Если вы используете зацикленные звуки, вам придется самим восстанавливать их состояние (запускать снова с помощью <code>set_sound()/add_sound()</code>) в функции <code>start()</code>.
</p>
</div>
<p>
Если вам не достаточно описанных здесь функций по работе со звуком, используйте модуль «sound».
</p>

</div>
<!-- EDIT25 SECTION "18. Музыка" [155439-163814] -->
<h1 class="sectionedit26" id="форматирование_и_оформление_вывода">19. Форматирование и оформление вывода</h1>
<div class="level1">

<p>
Обычно INSTEAD сам занимается форматированием и оформлением вывода. Например, отделяет статическую сцену от динамической. Выделяет курсивом действия игрока. Переводит фокус на изменение в тексте и т.д. Модули вроде «quotes», «para» и подобные улучшают качество вывода игры без дополнительных усилий со стороны автора. 
</p>

<p>
Например, я рекомендую всегда включать в вашу игру следующие модули:
</p>
<pre class="code lua">instead_version <span class="st0">&quot;1.8.2&quot;</span>
<span class="kw3">require</span> <span class="st0">&quot;para&quot;</span> <span class="co1">-- отступы параграфов</span>
requure <span class="st0">&quot;dash&quot;</span> <span class="co1">-- замена двойного минуса на длинное тире</span>
<span class="kw3">require</span> <span class="st0">&quot;quotes&quot;</span> <span class="co1">-- красивые кавычки</span></pre>

<p>
И ваша игра будет выглядеть гораздо лучше. Если вам нужна какая-то автоматическая обработка выводимого текста, вы можете включить модуль «format» и определить функцию <code>stead.filter</code>. Например:
</p>
<pre class="code lua">instead_version <span class="st0">&quot;1.8.2&quot;</span>
<span class="kw3">require</span> <span class="st0">&quot;format&quot;</span>
stead<span class="sy0">.</span>filter <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="br0">&#41;</span>
        <span class="kw1">return</span> s<span class="sy0">..</span><span class="st0">'^Эта строка будет добавлена к выводу'</span><span class="sy0">;</span>
<span class="kw1">end</span></pre>

<p>
Многие хорошие игры на INSTEAD никак не занимаются своим оформлением, кроме разбиения текста <code>dsc</code> на параграфы с помощью символов &#039;^^&#039;, поэтому подумайте, а так ли вам хочется заниматься оформлением своей игры вручную? 
</p>

<p>
Тем не менее, иногда это все-таки необходимо.
</p>

</div>
<!-- EDIT26 SECTION "19. Форматирование и оформление вывода" [163815-165826] -->
<h2 class="sectionedit27" id="форматирование">Форматирование</h2>
<div class="level2">

<p>
Вы можете делать простое форматирование текста с помощью функций:
</p>
<ul>
<li class="level1"><div class="li"> <code>txtc(строка)</code> - разместить по центру;</div>
</li>
<li class="level1"><div class="li"> <code>txtr(строка)</code> - разместить справа;</div>
</li>
<li class="level1"><div class="li"> <code>txtl(строка)</code> - разместить слева;</div>
</li>
<li class="level1"><div class="li"> <code>txttop(строка)</code> - сверху строки;</div>
</li>
<li class="level1"><div class="li"> <code>txtbottom(строка)</code> - снизу строки;</div>
</li>
<li class="level1"><div class="li"> <code>txtmiddle(строка)</code> - середина строки (по умолчанию);</div>
</li>
</ul>

<p>
Например:
</p>
<pre class="code lua">main <span class="sy0">=</span> room <span class="br0">&#123;</span>
	nam <span class="sy0">=</span> <span class="st0">'Intro'</span><span class="sy0">;</span>
	dsc <span class="sy0">=</span> txtc <span class="st0">'Добро пожаловать!'</span><span class="sy0">;</span> <span class="co1">-- если у функции только 1 параметр, </span>
        <span class="co1">-- скобки можно опускать;</span>
<span class="br0">&#125;</span></pre>

<p>
Вышеописанные функции влияют не только на текст, но и на изображения, вставленные с помощью <code>img()</code>.
Следует отметить, что если вы используете несколько функций форматирования, то предполагается, что они относятся к разным строкам (параграфам). В противном случае, результат не определен. Разбивайте текст на абзацы символами <code>^</code> или <code>pn()</code>.
</p>

<p>
INSTEAD при выводе удаляет лишние пробелы. Это значит, что неважно сколько пробелов вы вставляете между словами, все равно при выводе они не будут учитываться для расчета расстояния между словами. Иногда это может стать проблемой.
</p>

<p>
Вы можете создавать <em>неразрывные строки</em> с помощью: <code>txtnb(строка)</code>. Например, модуль «para» использует неразрывные строки для создания отступов в начале параграфов. Также, <code>txtnb</code> может оказаться удобной для вывода служебных символов. Можно сказать, что вся строка-параметр <code>txtnb</code> воспринимается движком как одно большое слово.
</p>

<p>
Еще один пример. Если вы используете подчеркивание текста, то промежутки между словами не будут подчеркнуты. При использовании <code>txtnb</code> промежутки также будут подчеркнуты. 
</p>

<p>
INSTEAD не поддерживает отображение таблиц, однако для вывода простых табличных данных можно воспользоваться <code>txttab()</code>. Эта функция используется для абсолютного позиционирования в строке (табулятор).
</p>

<p>
<code>txttab(позиция, [центр])</code>
</p>

<p>
<em>Позиция</em>, это текстовый или числовой параметр. Если задан числовой параметр, он воспринимается как позиция в пикселях. Если он задан в виде строкового параметра <code>число%</code>, то он воспринимается как позиция, выраженная в процентах от ширины окна вывода сцены.
</p>

<p>
Необязательный строковой параметр <em>центр</em> задает позицию в следующем за <code>txttab</code> слове, которая будет размещена по указанному смещению в строке. Позиции могут быть следующими:
</p>
<ul>
<li class="level1"><div class="li"> left;</div>
</li>
<li class="level1"><div class="li"> right;</div>
</li>
<li class="level1"><div class="li"> center;</div>
</li>
</ul>

<p>
По-умолчанию считается что задан параметр «left».
</p>

<p>
Так, например:
</p>
<pre class="code lua">main <span class="sy0">=</span> room <span class="br0">&#123;</span>
        nam <span class="sy0">=</span> <span class="st0">'Начало'</span><span class="sy0">;</span>
        <span class="co1">-- размещение 'Начало!' по центру строки</span>
        dsc <span class="sy0">=</span> txttab<span class="br0">&#40;</span><span class="st0">'50%'</span><span class="sy0">,</span> <span class="st0">'center'</span><span class="br0">&#41;</span><span class="sy0">..</span><span class="st0">'Начало!'</span><span class="sy0">;</span> 
<span class="br0">&#125;</span></pre>

<p>
Конечно, не очень удачный пример, так как то же самое можно было сделать с помощью <code>txtc()</code>. Более удачный пример.
</p>
<pre class="code lua">main <span class="sy0">=</span> room <span class="br0">&#123;</span>
        nam <span class="sy0">=</span> <span class="st0">'Начало'</span><span class="sy0">;</span>
        dsc <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="br0">&#41;</span>
                p<span class="br0">&#40;</span>txttab <span class="st0">'0%'</span><span class="br0">&#41;</span>
                p <span class="st0">&quot;Слева&quot;</span><span class="sy0">;</span>
                p<span class="br0">&#40;</span>txttab <span class="st0">'100%'</span><span class="sy0">,</span> <span class="st0">'right'</span><span class="br0">&#41;</span>
                p <span class="st0">&quot;Справа&quot;</span><span class="sy0">;</span>
        <span class="kw1">end</span>
<span class="br0">&#125;</span></pre>

<p>
На самом деле, единственная ситуация, когда применение <code>txttab</code> оправдано – это вывод табличных данных.
</p>

<p>
Следует отметить, что в ситуации, когда мы пишем что-то вроде:
</p>
<pre class="code lua">        <span class="co1">-- размещение 'Раз' по центру строки</span>
        dsc <span class="sy0">=</span> txttab<span class="br0">&#40;</span><span class="st0">'50%'</span><span class="sy0">,</span> <span class="st0">'center'</span><span class="br0">&#41;</span><span class="sy0">..</span><span class="st0">'Раз два три!'</span><span class="sy0">;</span></pre>

<p>
Только слово &#039;Раз&#039; будет помещено в центр строки, остальные слова будут дописаны справа от этого слова. Если вы хотите центрировать &#039;Раз два три!&#039; как одно целое, воспользуйтесь <code>txtnb()</code>.
</p>
<pre class="code lua">        <span class="co1">-- размещение 'Раз два три!' по центру строки</span>
        dsc <span class="sy0">=</span> txttab<span class="br0">&#40;</span><span class="st0">'50%'</span><span class="sy0">,</span> <span class="st0">'center'</span><span class="br0">&#41;</span><span class="sy0">..</span>txtnb <span class="st0">'Раз два три!'</span><span class="sy0">;</span> </pre>

<p>
По умолчанию, статическая часть сцены отделяется от динамической двойным переводом строки. Если вам это не подходит, вы можете переопределить <code>stead.scene_delim</code>, например:
</p>
<pre class="code lua">instead_version <span class="st0">&quot;1.8.2&quot;</span>
stead<span class="sy0">.</span>scene_delim <span class="sy0">=</span> <span class="st0">'^'</span> <span class="co1">-- одинарный перевод строки</span></pre>

<p>
Вы не можете менять эту переменную в обработчиках, так как она не сохраняется, но вы можете задать ее для игры целиком, или восстанавливать ее вручную в функции <code>start()</code>.
</p>

<p>
Если вас категорически не устраивает то, как INSTEAD формирует вывод (последовательность абзацов текста), вы можете переопределить функцию <code>iface.fmt</code>, которая по умолчанию выглядит следующим образом:
</p>
<pre class="code lua">iface<span class="sy0">.</span>fmt <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>self<span class="sy0">,</span> cmd<span class="sy0">,</span> st<span class="sy0">,</span> moved<span class="sy0">,</span> r<span class="sy0">,</span> av<span class="sy0">,</span> objs<span class="sy0">,</span> pv<span class="br0">&#41;</span> 
<span class="co1">-- st -- changed state (main win), move -- loc changed</span>
	<span class="kw1">local</span> l<span class="sy0">,</span> vv
	<span class="kw1">if</span> st <span class="kw1">then</span>
		av <span class="sy0">=</span> txtem<span class="br0">&#40;</span>av<span class="br0">&#41;</span><span class="sy0">;</span> <span class="co1">-- вывод &quot;важных&quot; life </span>
		pv <span class="sy0">=</span> txtem<span class="br0">&#40;</span>pv<span class="br0">&#41;</span><span class="sy0">;</span> <span class="co1">-- вывод обычных life</span>
		r <span class="sy0">=</span> txtem<span class="br0">&#40;</span>r<span class="br0">&#41;</span> <span class="co1">-- реакция на действие</span>
		<span class="kw1">if</span> isForcedsc<span class="br0">&#40;</span>stead<span class="sy0">.</span>here<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="kw2">or</span> NEED_SCENE <span class="kw1">then</span>
			l <span class="sy0">=</span> stead<span class="sy0">.</span>here<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">:</span>scene<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span> <span class="co1">-- статическая часть сцены</span>
		<span class="kw1">end</span>
	<span class="kw1">end</span>
	<span class="kw1">if</span> moved <span class="kw1">then</span> <span class="co1">-- компонуем вывод для случая, когда игрок перешел в новую комнату</span>
		vv <span class="sy0">=</span> stead<span class="sy0">.</span>fmt<span class="br0">&#40;</span>stead<span class="sy0">.</span>cat<span class="br0">&#40;</span>
                     stead<span class="sy0">.</span>par<span class="br0">&#40;</span>stead<span class="sy0">.</span>scene_delim<span class="sy0">,</span> r<span class="sy0">,</span> l<span class="sy0">,</span> av<span class="sy0">,</span> objs<span class="sy0">,</span> pv<span class="br0">&#41;</span><span class="sy0">,</span> <span class="st0">'^'</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
	<span class="kw1">else</span> <span class="co1">-- компонуем вывод, когда игрок не делал перехода</span>
		vv <span class="sy0">=</span> stead<span class="sy0">.</span>fmt<span class="br0">&#40;</span>stead<span class="sy0">.</span>cat<span class="br0">&#40;</span>
                     stead<span class="sy0">.</span>par<span class="br0">&#40;</span>stead<span class="sy0">.</span>scene_delim<span class="sy0">,</span> l<span class="sy0">,</span> r<span class="sy0">,</span> av<span class="sy0">,</span> objs<span class="sy0">,</span> pv<span class="br0">&#41;</span><span class="sy0">,</span> <span class="st0">'^'</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
	<span class="kw1">end</span>
	<span class="kw1">return</span> vv
<span class="kw1">end</span></pre>

<p>
Тот факт, что я привел здесь этот код, не означает, что я рекомендую переопределять эту функцию. Напротив, я категорически против такой сильной привязки к форматированию текста. Тем не менее, иногда возникает ситуация, когда полный контроль за последовательностью вывода необходим. Если вы пишите свою первую игру, просто пропустите этот текст.
</p>

</div>
<!-- EDIT27 SECTION "Форматирование" [165827-174155] -->
<h2 class="sectionedit28" id="оформление">Оформление</h2>
<div class="level2">

<p>
Вы можете менять начертание текста с помощью комбинаций функций:
</p>
<ul>
<li class="level1"><div class="li"> <code>txtb(строка)</code> - жирный текст;</div>
</li>
<li class="level1"><div class="li"> <code>txtem(строка)</code> - курсив;</div>
</li>
<li class="level1"><div class="li"> <code>txtu(строка)</code> - подчеркнутый текст;</div>
</li>
<li class="level1"><div class="li"> <code>txtst(строка)</code> - перечеркнутый текст;</div>
</li>
</ul>

<p>
Например:
</p>
<pre class="code lua">main <span class="sy0">=</span> room <span class="br0">&#123;</span>
	nam <span class="sy0">=</span> <span class="st0">'Intro'</span><span class="sy0">;</span>
	dsc <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span><span class="br0">&#41;</span>
                p <span class="br0">&#40;</span><span class="st0">'Вы находитесь в комнате '</span><span class="br0">&#41;</span>
                p <span class="br0">&#40;</span>txtb <span class="st0">'main'</span><span class="sy0">,</span> <span class="st0">'.'</span><span class="br0">&#41;</span><span class="sy0">;</span>
        <span class="kw1">end</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>

<p>
Строго говоря, INSTEAD не поддерживает одновременный вывод разными шрифтами в окно сцены (если не считать разное начертание), поэтому если вам все-таки требуется более гибкий контроль вывода, вы можете сделать следующее:
</p>
<ul>
<li class="level1"><div class="li"> Использовать графические вставки <code>img()</code>;</div>
</li>
<li class="level1"><div class="li"> Использовать модуль <code>fonts</code>, в котором реализована отрисовка разными шрифтами за счет модуля <code>sprite</code>;</div>
</li>
<li class="level1"><div class="li"> Использовать другой движок, так как скорее всего вы используете INSTEAD не по назначению.</div>
</li>
</ul>

</div>
<!-- EDIT28 SECTION "Оформление" [174156-175573] -->
<h1 class="sectionedit29" id="конструкторы_и_наследование">20. Конструкторы и наследование</h1>
<div class="level1">
<div class="wrap_center wrap_round wrap_important plugin_wrap">
<p>
<em class="u">Внимание!</em>
</p>

<p>
Если вы пишите свою первую игру, было бы лучше, если бы она была простая. Для простой игры информация из этой главы не понадобится. Более того, 90% игр на INSTEAD не использует вещей, описанных в этой главе!
</p>
</div>
<p>
Если вы пишите игру, в которой много однотипных объектов, возможно, вам захочется упростить их создание.
Конструктор, это функция, которая создает объект. На самом деле конструкции <code>obj</code>, <code>room</code>, <code>dlg</code> – все это конструкторы. Когда вы пишите что-то вроде:
</p>
<pre class="code lua">apple <span class="sy0">=</span> obj <span class="br0">&#123;</span>
        nam <span class="sy0">=</span> <span class="st0">'яблоко'</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>

<p>
Вызывается функция <code>obj</code> в качестве параметра к которой передается таблица { nam = &#039;яблоко&#039; }; Зная это, вы можете писать свои конструкторы. Например, рассмотрим такую задачу. Нужно создавать окна, любое окно можно разбить. Мы можем написать конструктор <code>window</code>.
</p>
<pre class="code lua">window <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>v<span class="br0">&#41;</span>
        v<span class="sy0">.</span>window <span class="sy0">=</span> <span class="kw4">true</span>
        <span class="kw1">if</span> v<span class="sy0">.</span>nam <span class="sy0">==</span> <span class="kw4">nil</span> <span class="kw1">then</span>
                v<span class="sy0">.</span>nam <span class="sy0">=</span> <span class="st0">'окно'</span>
        <span class="kw1">end</span>
        <span class="kw1">if</span> v<span class="sy0">.</span>dsc <span class="sy0">==</span> <span class="kw4">nil</span> <span class="kw1">then</span>
                v<span class="sy0">.</span>dsc <span class="sy0">=</span> <span class="st0">'Здесь есть {окно}'</span>
        <span class="kw1">end</span>
        v<span class="sy0">.</span>act <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="br0">&#41;</span>
                <span class="kw1">if</span> s<span class="sy0">.</span>_broken <span class="kw1">then</span>
                        p <span class="co2">[[Окно разбито.]]</span>
                <span class="kw1">else</span>
                        p <span class="co2">[[За окном темно.]]</span>
                <span class="kw1">end</span>
        <span class="kw1">end</span>
        <span class="kw1">if</span> v<span class="sy0">.</span>used <span class="sy0">==</span> <span class="kw4">nil</span> <span class="kw1">then</span>
                v<span class="sy0">.</span>used <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="sy0">,</span> w<span class="br0">&#41;</span>
                        <span class="kw1">if</span> w <span class="sy0">==</span> hammer <span class="kw1">then</span>
                                 <span class="kw1">if</span> s<span class="sy0">.</span>_broken <span class="kw1">then</span>
                                         p <span class="co2">[[Окно уже разбито.]]</span>
                                 <span class="kw1">else</span>
                                         p <span class="co2">[[Я разбил окно.]]</span>
                                         s<span class="sy0">.</span>_broken <span class="sy0">=</span> <span class="kw4">true</span><span class="sy0">;</span>
                                 <span class="kw1">end</span>
                        <span class="kw1">end</span>
                <span class="kw1">end</span>
        <span class="kw1">end</span>
        <span class="kw1">return</span> obj<span class="br0">&#40;</span>v<span class="br0">&#41;</span>
<span class="kw1">end</span></pre>

<p>
Мы видим, что функция <code>window</code> заполняет некоторые атрибуты и обработчики (позволяя игроку переопределить некоторые из них), а потом вызывает функцию создания объекта и возвращает новенький объект.
Теперь, можно создавать объекты окна:
</p>
<pre class="code lua">win1 <span class="sy0">=</span> window <span class="br0">&#123;</span>
        dsc <span class="sy0">=</span> <span class="st0">&quot;В восточной стене есть {окно}.&quot;</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>

<p>
Или, так как окно это обычно статический объект, можно создавать его прямо в <code>obj</code>.
</p>
<pre class="code lua">obj <span class="sy0">=</span> <span class="br0">&#123;</span> window <span class="br0">&#123;</span>
            dsc <span class="sy0">=</span> <span class="st0">'В восточной стене есть {окно}.'</span><span class="sy0">;</span>
      <span class="br0">&#125;</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre>

<p>
Если вам нравится более классический синтаксис оформления конструктора в виде функции, принимающей несколько параметров вместо одной таблицы (примеры: <code>vroom</code>, <code>vobj</code>, <code>vway</code> и подобные), то можно было бы определить конструктор так:
</p>
<pre class="code lua">window <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>nam<span class="sy0">,</span> dsc<span class="br0">&#41;</span>
        <span class="kw1">local</span> v <span class="sy0">=</span> <span class="br0">&#123;</span><span class="br0">&#125;</span> <span class="co1">-- создаем пустую таблицу</span>
        <span class="co1">-- заполняем ее</span>
        v<span class="sy0">.</span>window <span class="sy0">=</span> <span class="kw4">true</span>
        v<span class="sy0">.</span>nam <span class="sy0">=</span> <span class="st0">'окно'</span>
        <span class="kw1">if</span> dsc <span class="sy0">==</span> <span class="kw4">nil</span> <span class="kw1">then</span>
                v<span class="sy0">.</span>dsc <span class="sy0">=</span> <span class="st0">'Здесь есть {окно}'</span>
        <span class="kw1">end</span>
        v<span class="sy0">.</span>act <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="br0">&#41;</span>
                <span class="kw1">if</span> s<span class="sy0">.</span>_broken <span class="kw1">then</span>
                        p <span class="co2">[[Окно разбито.]]</span>
                <span class="kw1">else</span>
                        p <span class="co2">[[За окном темно.]]</span>
                <span class="kw1">end</span>
        <span class="kw1">end</span>
        v<span class="sy0">.</span>used <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="sy0">,</span> w<span class="br0">&#41;</span>
                <span class="kw1">if</span> w <span class="sy0">==</span> hammer <span class="kw1">then</span>
                         <span class="kw1">if</span> s<span class="sy0">.</span>_broken <span class="kw1">then</span>
                                 p <span class="co2">[[Окно уже разбито.]]</span>
                         <span class="kw1">else</span>
                                 p <span class="co2">[[Я разбил окно.]]</span>
                                 s<span class="sy0">.</span>_broken <span class="sy0">=</span> <span class="kw4">true</span><span class="sy0">;</span>
                         <span class="kw1">end</span>
                <span class="kw1">end</span>
        <span class="kw1">end</span>
        <span class="kw1">return</span> obj<span class="br0">&#40;</span>v<span class="br0">&#41;</span> <span class="co1">-- создаем объект</span>
<span class="kw1">end</span></pre>

<p>
Тогда вызов конструктора будет выглядеть по-другому:
</p>
<pre class="code lua">obj <span class="sy0">=</span> <span class="br0">&#123;</span> window <span class="br0">&#40;</span><span class="st0">'окно'</span><span class="sy0">,</span> <span class="st0">'В восточной стене есть {окно}.'</span><span class="br0">&#41;</span> <span class="br0">&#125;</span></pre>

<p>
На самом деле, оба подхода применимы, но в разных ситуациях. Если для создания объекта достаточно указать два-три атрибута, то проще и наглядней оформлять конструктор как функцию с несколькими параметрами (как <code>vroom</code>). 
</p>

<p>
Если же предполагается, что объекту могут быть присвоены различные (в том числе и необязательные) атрибуты, то проще делать конструктор в виде функции, принимающей таблицу (как <code>obj/room</code> и др.)
</p>

<p>
Отдельно стоит рассмотреть вопрос добавления новых переменных. В нашем примере мы использовали переменную с префиксом <code>_</code>, так как такие переменные можно создавать на лету. Другим способом является использование <code>stead.add_var()</code>, например:
</p>
<pre class="code lua">window <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>v<span class="br0">&#41;</span>
        stead<span class="sy0">.</span>add_var<span class="br0">&#40;</span>v<span class="sy0">,</span> <span class="br0">&#123;</span> broken <span class="sy0">=</span> <span class="kw4">false</span> <span class="br0">&#125;</span><span class="br0">&#41;</span> <span class="co1">-- добавить переменные к ''v'';</span>
        v<span class="sy0">.</span>window <span class="sy0">=</span> <span class="kw4">true</span>
<span class="co1">-- ... пропущено</span>
        <span class="kw1">if</span> v<span class="sy0">.</span>used <span class="sy0">==</span> <span class="kw4">nil</span> <span class="kw1">then</span>
                v<span class="sy0">.</span>used <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="sy0">,</span> w<span class="br0">&#41;</span>
                        <span class="kw1">if</span> w <span class="sy0">==</span> hammer <span class="kw1">then</span>
                                 <span class="kw1">if</span> s<span class="sy0">.</span>broken <span class="kw1">then</span>
                                         p <span class="co2">[[Окно уже разбито.]]</span>
                                 <span class="kw1">else</span>
                                         p <span class="co2">[[Я разбил окно.]]</span>
                                         s<span class="sy0">.</span>broken <span class="sy0">=</span> <span class="kw4">true</span><span class="sy0">;</span>
                                 <span class="kw1">end</span>
                        <span class="kw1">end</span>
                <span class="kw1">end</span>
        <span class="kw1">end</span>
        <span class="kw1">return</span> obj<span class="br0">&#40;</span>v<span class="br0">&#41;</span>
<span class="kw1">end</span></pre>

<p>
Если вы хотите добавить глобальную переменную (на лету), используйте синтаксис:
</p>
<pre class="code lua">stead<span class="sy0">.</span>add_var <span class="br0">&#123;</span> global_var <span class="sy0">=</span> <span class="nu0">1</span> <span class="br0">&#125;</span>
<span class="co1">-- синоним записи stead.add_var ({ global_var = 1 })</span></pre>

<p>
Теперь, если вы поняли что-такое конструктор, вы можете перейти к такому понятию, как наследование.
</p>

<p>
На самом деле, в примерах выше уже используется наследование. Действительно, ведь конструктор <code>window</code> вызывает другой конструктор <code>obj</code>, тем самым получая все свойства обычного объекта. Также, <code>winodw</code> определяет переменную признак <code>window</code>, чтобы в игре мы могли понять, что мы имеем дело с окном. Например:
</p>
<pre class="code lua">use <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="sy0">,</span> w<span class="br0">&#41;</span>
        <span class="kw1">if</span> w<span class="sy0">.</span>window <span class="kw1">then</span>
                p <span class="co2">[[Я посветил фонариком в окно.]]</span>
                <span class="kw1">return</span>
        <span class="kw1">end</span>
<span class="kw1">end</span></pre>

<p>
Для иллюстрации механизма наследования создадим класс объектов <code>treasure</code>, те. сокровищ.
</p>
<pre class="code lua">global <span class="br0">&#123;</span> score <span class="sy0">=</span> <span class="nu0">0</span> <span class="br0">&#125;</span>
treasure <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span><span class="br0">&#41;</span>
        <span class="kw1">local</span> v <span class="sy0">=</span> <span class="br0">&#123;</span><span class="br0">&#125;</span>
        v<span class="sy0">.</span>nam <span class="sy0">=</span> <span class="st0">'сокровище'</span>
        v<span class="sy0">.</span>treasure <span class="sy0">=</span> <span class="kw4">true</span>
        v<span class="sy0">.</span>_points <span class="sy0">=</span> <span class="nu0">100</span>
        v<span class="sy0">.</span>dsc <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="br0">&#41;</span>
                p <span class="br0">&#40;</span><span class="st0">'Здесь есть {'</span><span class="sy0">,</span> stead<span class="sy0">.</span>dispof<span class="br0">&#40;</span>s<span class="br0">&#41;</span><span class="sy0">,</span> <span class="st0">'}.'</span><span class="br0">&#41;</span>
        <span class="kw1">end</span><span class="sy0">;</span>
        v<span class="sy0">.</span>inv <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="br0">&#41;</span>
                p <span class="br0">&#40;</span><span class="st0">'Это же '</span><span class="sy0">,</span> stead<span class="sy0">.</span>dispof<span class="br0">&#40;</span>s<span class="br0">&#41;</span><span class="sy0">,</span> <span class="st0">'.'</span><span class="br0">&#41;</span><span class="sy0">;</span>
        <span class="kw1">end</span><span class="sy0">;</span>
        v<span class="sy0">.</span>tak <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="br0">&#41;</span>
                score <span class="sy0">=</span> score <span class="sy0">+</span> s<span class="sy0">.</span>points<span class="sy0">;</span> <span class="co1">-- увеличим счет</span>
                p <span class="co2">[[Дрожащими руками я забрал сокровища.]]</span><span class="sy0">;</span>
        <span class="kw1">end</span>
        <span class="kw1">return</span> obj<span class="br0">&#40;</span>v<span class="br0">&#41;</span>
<span class="kw1">end</span></pre>

<p>
А теперь, на его основе создадим золото, алмаз и сундук.
</p>
<pre class="code lua">gold <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>dsc<span class="br0">&#41;</span>
        <span class="kw1">local</span> v <span class="sy0">=</span> treasure<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
        v<span class="sy0">.</span>nam <span class="sy0">=</span> <span class="st0">'золото'</span><span class="sy0">;</span>
        v<span class="sy0">.</span>gold <span class="sy0">=</span> <span class="kw4">true</span><span class="sy0">;</span>
        v<span class="sy0">.</span>points <span class="sy0">=</span> <span class="nu0">50</span><span class="sy0">;</span>
        v<span class="sy0">.</span>dsc <span class="sy0">=</span> dsc<span class="sy0">;</span>
        <span class="kw1">return</span> v
<span class="kw1">end</span>
diamond <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>dsc<span class="br0">&#41;</span>
        <span class="kw1">local</span> v <span class="sy0">=</span> treasure<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
        v<span class="sy0">.</span>nam <span class="sy0">=</span> <span class="st0">'алмаз'</span><span class="sy0">;</span>
        v<span class="sy0">.</span>diamond <span class="sy0">=</span> <span class="kw4">true</span><span class="sy0">;</span>
        v<span class="sy0">.</span>points <span class="sy0">=</span> <span class="nu0">200</span><span class="sy0">;</span>
        v<span class="sy0">.</span>dsc <span class="sy0">=</span> dsc<span class="sy0">;</span>
        <span class="kw1">return</span> v
<span class="kw1">end</span>
chest <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>dsc<span class="br0">&#41;</span>
        <span class="kw1">local</span> v <span class="sy0">=</span> treasure<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
        v<span class="sy0">.</span>nam <span class="sy0">=</span> <span class="st0">'сундук'</span><span class="sy0">;</span>
        v<span class="sy0">.</span>chest <span class="sy0">=</span> <span class="kw4">true</span>
        v<span class="sy0">.</span>points <span class="sy0">=</span> <span class="nu0">1000</span><span class="sy0">;</span>
        v<span class="sy0">.</span>dsc <span class="sy0">=</span> dsc<span class="sy0">;</span>
        <span class="kw1">return</span> v
<span class="kw1">end</span></pre>

<p>
Теперь, в игре можно создавать сокровища через конструкторы:
</p>
<pre class="code lua">diamond1 <span class="sy0">=</span> diamond<span class="br0">&#40;</span><span class="st0">&quot;В грязи я заметил {алмаз}.&quot;</span><span class="br0">&#41;</span>
diamond2 <span class="sy0">=</span> diamond<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span> <span class="co1">-- тут будет стандартное описание алмаза</span>
gold1 <span class="sy0">=</span> gold<span class="br0">&#40;</span><span class="st0">&quot;В углу я заметил блеск {золота}.&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
cave <span class="sy0">=</span> room <span class="br0">&#123;</span>
        nam <span class="sy0">=</span> <span class="st0">'пещера'</span><span class="sy0">;</span>
        obj <span class="sy0">=</span> <span class="br0">&#123;</span> 
                <span class="st0">'diamond1'</span><span class="sy0">,</span> 
                <span class="st0">'gold1'</span><span class="sy0">,</span>
                chest<span class="br0">&#40;</span><span class="st0">&quot;А еще я вижу {сундук}!&quot;</span><span class="br0">&#41;</span>
        <span class="br0">&#125;</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>

<p>
На самом деле, как именно писать функции-конструкторы и реализовывать принцип наследования, зависит только от вас. Выберете наиболее простой и понятный способ.
</p>

<p>
При написании конструкторов иногда бывает полезным сделать вызов обработчика так, как это делает INSTEAD. Для этого используется <code>stead.call(объект, метод, параметры)</code>, при этом эта функция вернет реакцию атрибута в виде строки. Например, рассмотрим модификацию <code>window</code>, которая заключается в том, что можно определять свою реакцию на осмотр окна, которая будет выполнена после стандартного сообщения о том, что это разбитое окно (если оно разбито).
</p>
<pre class="code lua">window <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>nam<span class="sy0">,</span> dsc<span class="sy0">,</span> what<span class="br0">&#41;</span>
        <span class="kw1">local</span> v <span class="sy0">=</span> <span class="br0">&#123;</span><span class="br0">&#125;</span> <span class="co1">-- создаем пустую таблицу</span>
        <span class="co1">-- заполняем ее</span>
        v<span class="sy0">.</span>window <span class="sy0">=</span> <span class="kw4">true</span>
        v<span class="sy0">.</span>nam <span class="sy0">=</span> <span class="st0">'окно'</span>
        v<span class="sy0">.</span>what <span class="sy0">=</span> what
        <span class="kw1">if</span> dsc <span class="sy0">==</span> <span class="kw4">nil</span> <span class="kw1">then</span>
                v<span class="sy0">.</span>dsc <span class="sy0">=</span> <span class="st0">'Здесь есть {окно}'</span>
        <span class="kw1">end</span>
        v<span class="sy0">.</span>act <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="br0">&#41;</span>
                <span class="kw1">if</span> s<span class="sy0">.</span>_broken <span class="kw1">then</span>
                        p <span class="co2">[[Окно разбито.]]</span>
                <span class="kw1">end</span>
                <span class="kw1">local</span> r <span class="sy0">=</span> stead<span class="sy0">.</span><span class="kw3">call</span><span class="br0">&#40;</span>s<span class="sy0">,</span> <span class="st0">'what'</span><span class="br0">&#41;</span>
                <span class="kw1">if</span> r <span class="kw1">then</span> 
                        p<span class="br0">&#40;</span>r<span class="br0">&#41;</span>
                <span class="kw1">else</span>
                        p <span class="co2">[[За окном темно.]]</span>
                <span class="kw1">end</span>
        <span class="kw1">end</span>
<span class="sy0">...</span></pre>

<p>
Таким образом, мы можем при создании окна задать третий параметр, в котором определить функцию или строку, которая будет реакцией во время осмотра окна. При этом сообщение о том, что окно разбито (если оно действительно разбито), будет выведено перед этой реакцией.
</p>

<p>
В качестве завершающего примера, рассмотрим свою версию реализации <code>vway</code>, назовем ее <code>xway</code> (Впрочем, в <code>lua</code> можно переопределять функции. Вы можете, например, написать свою версию <code>vway</code> и она заменит ту, что определена в INSTEAD).
</p>
<pre class="code lua"><span class="kw1">function</span> xway<span class="br0">&#40;</span>name<span class="sy0">,</span> dsc<span class="sy0">,</span> w<span class="br0">&#41;</span>
        <span class="kw1">return</span>  obj <span class="br0">&#123;</span> 
                nam <span class="sy0">=</span> name<span class="sy0">;</span>
                dsc <span class="sy0">=</span> dsc<span class="sy0">;</span>
                act <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="br0">&#41;</span>
                        walk<span class="br0">&#40;</span>s<span class="sy0">.</span>where<span class="br0">&#41;</span>
                <span class="kw1">end</span><span class="sy0">;</span>
                where <span class="sy0">=</span> w<span class="sy0">;</span>
       <span class="br0">&#125;</span><span class="sy0">;</span>
<span class="kw1">end</span></pre>

<p>
Как видим, <code>xway</code> реализован как объект, который при клике выполняет <code>xwalk</code> в заданную при создании <code>xway</code> комнату.
</p>

<p>
На самом деле, у <code>xway</code> есть один недостаток, по сравнению с <code>vway</code>. Это невозможность создания объектов на лету, например, если вы напишите:
</p>
<pre class="code lua">put <span class="br0">&#40;</span>xway<span class="br0">&#40;</span><span class="st0">'в пещеру'</span><span class="sy0">,</span> <span class="st0">'{В пещеру}'</span><span class="sy0">,</span> <span class="st0">'cave'</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
То INSTEAD не сможет сохранить этот объект. Это произойдет потому, что вообще говоря, INSTEAD умеет сохранять только те объекты, которые имеют дескрипторы. Объекты, имеющие дескрипторы, это объекты созданные одним из следующих способов:
</p>
<ol>
<li class="level1"><div class="li"> Явным присвоением дескриптору в глобальном контексте (apple = obj {… ); </div>
</li>
<li class="level1"><div class="li"> Явным созданием внутри списков <code>obj</code> и <code>way</code> (дескриптором станет элемент массива);</div>
</li>
<li class="level1"><div class="li"> Через механизм <code>new</code> (описано ниже).</div>
</li>
</ol>

<p>
В случае же с <code>put</code> мы создаем абсолютно безымянный объект. Тем не менее существует способ сделать объекты сохраняемыми в любом случае. То, что я опишу далее, вряд ли стоит использовать при написании игр. Обычно такие вещи имеют смысл при разработке модулей или расширений движка, так что вы можете спокойно пропустить эту часть.
</p>

<p>
Итак, для сохранения можно определить свою функцию <em>сохранения</em>.
</p>
<pre class="code lua"><span class="kw1">function</span> xway<span class="br0">&#40;</span>name<span class="sy0">,</span> dsc<span class="sy0">,</span> w<span class="br0">&#41;</span>
        <span class="kw1">return</span>  obj <span class="br0">&#123;</span> 
                nam <span class="sy0">=</span> name<span class="sy0">;</span>
                dsc <span class="sy0">=</span> dsc<span class="sy0">;</span>
                act <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="br0">&#41;</span>
                        walk<span class="br0">&#40;</span>s<span class="sy0">.</span>where<span class="br0">&#41;</span>
                <span class="kw1">end</span><span class="sy0">;</span>
                where <span class="sy0">=</span> w<span class="sy0">;</span>
                save <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>self<span class="sy0">,</span> name<span class="sy0">,</span> h<span class="sy0">,</span> need<span class="br0">&#41;</span>
                        <span class="co1">-- self - текущий объект</span>
                        <span class="co1">-- name -- полное имя переменной</span>
                        <span class="co1">-- h - файловый дескриптор файла сохранения</span>
                        <span class="co1">-- need - признак того, что это создание объекта, </span>
                        <span class="co1">-- файл сохранения должен создать объект </span>
                        <span class="co1">-- при загрузке</span>
                        <span class="kw1">local</span> dsc <span class="sy0">=</span> self<span class="sy0">.</span>dsc<span class="sy0">;</span>
                        <span class="kw1">local</span> w <span class="sy0">=</span> stead<span class="sy0">.</span>deref<span class="br0">&#40;</span>self<span class="sy0">.</span>where<span class="br0">&#41;</span><span class="sy0">;</span>
                        <span class="kw1">if</span> need <span class="kw1">then</span> 
                        <span class="co1">-- в случае создания, запишем строку </span>
                        <span class="co1">-- с вызовом конструктора</span>
                                h<span class="sy0">:</span><span class="kw3">write</span><span class="br0">&#40;</span>stead<span class="sy0">.</span><span class="kw3">string.format</span><span class="br0">&#40;</span>
                                         <span class="st0">&quot;%s  = xway(%s, %s, %s);<span class="es1">\n</span>&quot;</span><span class="sy0">,</span>
                                         name<span class="sy0">,</span>
                                         <span class="co1">-- формирование строк</span>
                                         stead<span class="sy0">.</span><span class="kw3">tostring</span><span class="br0">&#40;</span>self<span class="sy0">.</span>nam<span class="br0">&#41;</span><span class="sy0">,</span>                                     
                                         stead<span class="sy0">.</span><span class="kw3">tostring</span><span class="br0">&#40;</span>dsc<span class="br0">&#41;</span><span class="sy0">,</span>
                                         stead<span class="sy0">.</span><span class="kw3">tostring</span><span class="br0">&#40;</span>w<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
                        <span class="kw1">end</span>
                        stead<span class="sy0">.</span>savemembers<span class="br0">&#40;</span>h<span class="sy0">,</span> self<span class="sy0">,</span> name<span class="sy0">,</span> <span class="kw4">false</span><span class="br0">&#41;</span><span class="sy0">;</span> <span class="co1">-- сохраним все </span>
                        <span class="co1">-- остальные переменные объекта</span>
                        <span class="co1">-- например, состояние включен/выключен</span>
                        <span class="co1">-- итд</span>
                        <span class="co1">-- false в последней позиции означает что будет </span>
                        <span class="co1">-- передано в save-методы вложенных объектов в </span>
                        <span class="co1">-- качестве параметра need</span>
               <span class="kw1">end</span>
      <span class="br0">&#125;</span><span class="sy0">;</span>
<span class="kw1">end</span></pre>

<p>
На самом деле, я надеюсь, что вам никогда не понадобится разбираться с движком на таком глубоком уровне.
</p>

</div>
<!-- EDIT29 SECTION "20. Конструкторы и наследование" [175574-192853] -->
<h1 class="sectionedit30" id="полезные_советы">21. Полезные советы</h1>
<div class="level1">

</div>
<!-- EDIT30 SECTION "21. Полезные советы" [192854-192902] -->
<h2 class="sectionedit31" id="разбиение_на_файлы">Разбиение на файлы</h2>
<div class="level2">

<p>
Когда ваша игра становится большой, размещение ее кода целиком в <code>main.lua</code> – плохая идея.
</p>

<p>
Для разбиения текста игры на файлы вы можете использовать <code>dofile</code>. Вы должны использовать <code>dofile</code> в глобальном контексте таким образом, чтобы во время загрузки <code>main.lua</code> загрузились и все остальные фрагменты игры, например.
</p>
<pre class="code lua"><span class="co1">-- main.lua</span>
instead_version <span class="st0">&quot;1.8.2&quot;</span>
<span class="kw3">dofile</span> <span class="st0">&quot;episode1.lua&quot;</span>
<span class="kw3">dofile</span> <span class="st0">&quot;npc.lau&quot;</span>
<span class="kw3">dofile</span> <span class="st0">&quot;start.lua&quot;</span>
&nbsp;
main <span class="sy0">=</span> room <span class="br0">&#123;</span>
<span class="sy0">....</span></pre>

<p>
Как именно разбивать исходный текст на файлы зависит только от вас. Я использую файлы в соответствии с эпизодами игры (которые обычно слабо связаны между собой), но можно создавать файлы, хранящие отдельно комнаты, объекты, диалоги и т.д. Это вопрос личного удобства. 
</p>

<p>
Также есть возможность динамически подгружать части игры (с возможностью переопределения существующих объектов). Для этого вы можете воспользоваться функцией <code>gamefile</code>:
</p>
<pre class="code lua"><span class="sy0">...</span>
act <span class="sy0">=</span> code <span class="co2">[[ gamefile (&quot;episode2.lua&quot;); ]]</span>
<span class="sy0">...</span></pre>

<p>
<code>gamefile</code> также позволяет загрузить новый файл и забыть стек предыдущих загрузок, запустив этот новый файл как самостоятельную игру. Для этого, задайте второй параметр функции как <code>true</code>. <code>gamefile</code> можно использовать только в обработчиках.
</p>
<pre class="code lua"><span class="sy0">...</span>
act <span class="sy0">=</span> code <span class="co2">[[ gamefile (&quot;episode3.lua&quot;, true); ]]</span>
<span class="sy0">...</span></pre>

<p>
Во втором варианте <code>gamefile</code> можно использовать для оформления мультиязычных игр или игр-сборников, где фактически из оболочки выполняется запуск самостоятельной игры.
</p>

</div>
<!-- EDIT31 SECTION "Разбиение на файлы" [192903-195325] -->
<h2 class="sectionedit32" id="модули">Модули</h2>
<div class="level2">

<p>
Дополнительная функциональность часто реализована в INSTEAD в виде модулей. Для использования модуля необходимо после «instead_version» написать:
</p>
<pre class="code lua"><span class="kw3">require</span> <span class="st0">&quot;имя модуля&quot;</span></pre>

<p>
Часть модулей входит в поставку INSTEAD, но есть и такие, которые вы можете скачать отдельно и положить в каталог с игрой. Вы можете заменить любой стандартный модуль своим, если положите его в каталог с игрой под тем-же именем файла, что и стандартный.
</p>

<p>
Модуль, это фактически <code>lua</code> файл с именем: <code>имя_модуля.lua</code>. 
</p>

<p>
Самая свежая документация по модулям размещена здесь: <a href="http://instead.syscall.ru/wiki/ru/gamedev/modules" class="urlextern" title="http://instead.syscall.ru/wiki/ru/gamedev/modules"  rel="nofollow">http://instead.syscall.ru/wiki/ru/gamedev/modules</a>
</p>

<p>
<strong><em><a href="/wiki/ru/gamedev/modules" class="wikilink1" title="ru:gamedev:modules">Подробнее о модулях</a></em></strong>
</p>

<p>
Ниже перечислены основные модули, с указанием функциональности, которые они предоставляют.
</p>
<ul>
<li class="level1"><div class="li"> <code>dbg</code> — модуль отладки (<code>require «dbg»</code> – включить отладчик);</div>
</li>
<li class="level2"><div class="li"> <code>xact</code> — реализация ссылок;</div>
</li>
<li class="level2"><div class="li"> <code>click</code> — модуль перехвата кликов мыши по картинке сцены;</div>
</li>
<li class="level2"><div class="li"> <code>prefs</code> — модуль настроек (хранилище данных настроек);</div>
</li>
<li class="level2"><div class="li"> <code>snapshots</code> — модуль поддержки снапшотов (для откатов игровых ситуаций);</div>
</li>
<li class="level2"><div class="li"> <code>format</code> — модуль оформления вывода;</div>
</li>
<li class="level2"><div class="li"> <code>theme</code> — управление темой на лету;</div>
</li>
<li class="level2"><div class="li"> <code>hideinv</code> - модуль работы с инвентарем;</div>
</li>
<li class="level2"><div class="li"> <code>kbd</code> - модуль обработки событий срабатывания клавиш;</div>
</li>
<li class="level2"><div class="li"> <code>timer</code> - модуль отсчета времени;</div>
</li>
<li class="level2"><div class="li"> <code>sprites</code> — модуль для работы со спрайтами;</div>
</li>
<li class="level2"><div class="li"> <code>sound</code> — модуль работы со звуком;</div>
</li>
<li class="level2"><div class="li"> <code>nouse</code> — модуль обработки реакций на не заданные действия при использовании объекта;</div>
</li>
<li class="level2"><div class="li"> <code>counters</code> — модуль счетчиков событий;</div>
</li>
<li class="level2"><div class="li"> <code>wroom</code> — модуль создания «умных» переходов;</div>
</li>
<li class="level2"><div class="li"> <code>nolife</code> – модуль блокировки методов life;</div>
</li>
<li class="level2"><div class="li"> <code>proxymenu</code> – модуль меню в стиле адвенчур на ZX-80.</div>
</li>
</ul>

<p>
Пример загрузки модулей:
</p>
<pre class="code lua"><span class="co1">--$Name: Моя игра!$</span>
instead_version <span class="st0">&quot;1.8.2&quot;</span>
<span class="kw3">require</span> <span class="st0">&quot;para&quot;</span>
<span class="kw3">require</span> <span class="st0">&quot;dbg&quot;</span>
<span class="sy0">...</span></pre>

</div>
<!-- EDIT32 SECTION "Модули" [195326-198251] -->
<h2 class="sectionedit33" id="меню">Меню</h2>
<div class="level2">

<p>
Стандартное поведение предмета инвентаря состоит в том, что игрок должен сделать два щелчка мышью. Это необходимо потому, что каждый предмет инвентаря может быть использован на другой предмет сцены или инвентаря. После второго щелчка происходит игровой такт игры. Иногда такое поведение может быть нежелательным. Возможно, вы захотите сделать игру в которой игровая механика отличается от классических INSTEAD игр. Тогда вам может понадобится меню.
</p>

<p>
Меню – это элемент инвентаря, который срабатывает на первый клик. При этом меню может сообщить движку, что действие не является игровым тактом. Таким образом, используя меню вы можете создать в зоне инвентаря управление игрой любой сложности. Например, существует модуль «proxymenu», который реализует управление игрой в стиле квестов на ZX-«Спектрум». В игре «Особняк» свое управление, которое вводит несколько модификаторов действий, и т.д.
</p>

<p>
Итак, вы можете делать меню в области инвентаря, определяя объекты с типом <code>menu</code>. При этом, обработчик меню (<code>menu</code>) будет вызван после одного клика мыши. Если обработчик не возвращает текст, то состояние игры не изменяется. Например, реализация кармана:
</p>
<pre class="code lua">pocket <span class="sy0">=</span> menu <span class="br0">&#123;</span>
	var <span class="br0">&#123;</span> 
                state <span class="sy0">=</span> <span class="kw4">false</span> 
        <span class="br0">&#125;</span><span class="sy0">;</span>
        nam <span class="sy0">=</span> <span class="st0">'карман'</span><span class="sy0">;</span>
	disp <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="br0">&#41;</span>
		<span class="kw1">if</span> s<span class="sy0">.</span>state <span class="kw1">then</span>
			<span class="kw1">return</span> txtu<span class="br0">&#40;</span><span class="st0">'карман'</span><span class="br0">&#41;</span><span class="sy0">;</span> <span class="co1">-- подчеркиваем активный карман</span>
		<span class="kw1">end</span> 
		<span class="kw1">return</span> <span class="st0">'карман'</span><span class="sy0">;</span>
	<span class="kw1">end</span><span class="sy0">;</span>
	gen <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="br0">&#41;</span>
		<span class="kw1">if</span> s<span class="sy0">.</span>state <span class="kw1">then</span>
			s<span class="sy0">:</span>enable_all<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span> <span class="co1">-- показать все предметы в кармане</span>
		<span class="kw1">else</span>
			s<span class="sy0">:</span>disable_all<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span> <span class="co1">-- спрятать все предметы в кармане</span>
		<span class="kw1">end</span> 
	<span class="kw1">end</span><span class="sy0">;</span>
	menu <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="br0">&#41;</span>
                s<span class="sy0">.</span>state <span class="sy0">=</span> <span class="kw2">not</span> s<span class="sy0">.</span>state <span class="co1">-- изменить состояние</span>
		s<span class="sy0">:</span>gen<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span> <span class="co1">-- открыть или закрыть карман</span>
	<span class="kw1">end</span><span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span>
&nbsp;
knife <span class="sy0">=</span> obj <span class="br0">&#123;</span>
	nam <span class="sy0">=</span> <span class="st0">'нож'</span><span class="sy0">;</span>
	inv <span class="sy0">=</span> <span class="st0">'Это нож'</span><span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span>
&nbsp;
<span class="kw1">function</span> init<span class="br0">&#40;</span><span class="br0">&#41;</span>
    take<span class="br0">&#40;</span>pocket<span class="br0">&#41;</span>
    put<span class="br0">&#40;</span>knife<span class="sy0">,</span> pocket<span class="br0">&#41;</span> <span class="co1">-- нож будет в кармане</span>
    pocket<span class="sy0">:</span>gen<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="co1">-- проинициализируем карман</span>
<span class="kw1">end</span>
&nbsp;
main <span class="sy0">=</span> room <span class="br0">&#123;</span>
	nam <span class="sy0">=</span> <span class="st0">'test'</span><span class="sy0">,</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre>

</div>
<!-- EDIT33 SECTION "Меню" [198252-201277] -->
<h2 class="sectionedit34" id="статус_игрока">Статус игрока</h2>
<div class="level2">

<p>
Иногда возникает желание выводит какой-нибудь статус. Например, количество игровых очков, состояние героя или, наконец, время суток. INSTEAD не предоставляет каких-то других областей вывода, кроме сцены и инвентаря, поэтому, самым простым способом вывода статуса является вывод его в зону инвентаря.
</p>

<p>
Ниже представлена реализация статуса игрока в виде текста, который появляется в инвентаре, но не может быть выбран, то есть, выглядит просто как текст.
</p>
<pre class="code lua">global <span class="br0">&#123;</span>
    life <span class="sy0">=</span> <span class="nu0">10</span><span class="sy0">;</span>
    power <span class="sy0">=</span> <span class="nu0">10</span><span class="sy0">;</span>
<span class="br0">&#125;</span>
&nbsp;
status <span class="sy0">=</span> stat <span class="br0">&#123;</span> <span class="co1">-- stat -- объект &quot;статус&quot;</span>
        nam <span class="sy0">=</span> <span class="st0">'статус'</span><span class="sy0">;</span>
	disp <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="br0">&#41;</span>
		pn <span class="br0">&#40;</span><span class="st0">'Жизнь: '</span><span class="sy0">,</span> life<span class="br0">&#41;</span>
                pn <span class="br0">&#40;</span><span class="st0">'Сила: '</span><span class="sy0">,</span> power<span class="br0">&#41;</span>
	<span class="kw1">end</span>
<span class="br0">&#125;</span><span class="sy0">;</span>
take<span class="br0">&#40;</span>status<span class="br0">&#41;</span></pre>

</div>
<!-- EDIT34 SECTION "Статус игрока" [201278-202394] -->
<h2 class="sectionedit35" id="walk_из_обработчиков_exit_и_enter">walk из обработчиков exit и enter</h2>
<div class="level2">

<p>
Вы можете делать <code>walk</code> из обработчиков <code>enter</code> и <code>exit</code>. Например, <code>vroom</code> реализован как комната с обработчиком <code>enter</code>, который переносит игрока в другую комнату. Если бы не было <code>vroom</code>, можно было бы написать переход без него следующим образом:
</p>
<pre class="code lua">home <span class="sy0">=</span> room <span class="br0">&#123;</span>
       nam <span class="sy0">=</span> <span class="st0">'Дома'</span><span class="sy0">;</span>
<span class="sy0">...</span>
        way <span class="sy0">=</span> <span class="br0">&#123;</span>
                room <span class="br0">&#123;</span>
                        nam <span class="sy0">=</span> <span class="st0">'На улицу'</span><span class="sy0">;</span>
                        enter <span class="sy0">=</span> code <span class="co2">[[ walk 'street' ]]</span><span class="sy0">;</span>
                <span class="br0">&#125;</span><span class="sy0">;</span>
        <span class="br0">&#125;</span></pre>

</div>
<!-- EDIT35 SECTION "walk из обработчиков exit и enter" [202395-203123] -->
<h2 class="sectionedit36" id="динамически_создаваемые_ссылки">Динамически создаваемые ссылки.</h2>
<div class="level2">

<p>
Строго говоря, ссылок в INSTEAD нет. Есть объекты и переходы. 
</p>

<p>
Динамически создаваемые ссылки могут быть реализованы разным способом.
</p>
<ol>
<li class="level1"><div class="li"> Через включение/выключение объектов/переходов;</div>
</li>
<li class="level1"><div class="li"> Через динамическое добавление/удаление объектов/переходов;</div>
</li>
</ol>

<p>
Следует заметить, что объекты типа <code>vway, vobj</code> и переходы <code>vroom, wroom</code> сделаны таким образом, что могут создаваться на лету, это делает возможным записи вида:
</p>
<pre class="code lua">put<span class="br0">&#40;</span>vway<span class="br0">&#40;</span><span class="st0">'Дорога'</span><span class="sy0">,</span> <span class="st0">'Я заметил {дорогу}, ведущую в лес...'</span><span class="sy0">,</span> <span class="st0">'forest'</span><span class="br0">&#41;</span><span class="sy0">,</span> field<span class="br0">&#41;</span><span class="sy0">;</span> 
<span class="co1">-- добавили ''vway'' в сцену field</span></pre>

<p>
Однако, я рекомендую использование <code>enable/disable()</code>.
</p>

</div>
<!-- EDIT36 SECTION "Динамически создаваемые ссылки." [203124-204188] -->
<h2 class="sectionedit37" id="кодирование_исходного_кода_игры">Кодирование исходного кода игры</h2>
<div class="level2">

<p>
Если вы не хотите показывать исходный код своих игр, вы можете закодировать исходный код с помощью параметра командной строки <code>-encode</code>:
</p>

<p>
<code>sdl-instead -encode &lt;путь к файлу&gt; [выходной путь]</code>
</p>

<p>
И использовать закодированный файл с помощью lua функции <code>doencfile</code>. При этом главный файл <code>main.lua</code> необходимо оставлять открытым. Таким образом, схема выглядит следующим образом (<code>game</code> – закодированный <code>game.lua</code>):
</p>
<pre class="code lua"><span class="co1">-- $Name: Моя закрытая игра!$</span>
instead_version <span class="st0">&quot;1.8.2&quot;</span>
doencfile<span class="br0">&#40;</span><span class="st0">&quot;game&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span> <span class="co1">-- никто не узнает, как ее пройти!</span></pre>
<div class="wrap_center wrap_round wrap_important plugin_wrap">
<p>
<em><em class="u"><strong>Осторожно!</strong></em></em>
</p>

<p>
Не используйте компиляцию игр с помощью <span class="wrap_em ">luac</span>, так как <span class="wrap_em ">luac</span> создает платформозависимый код!
Однако, компиляция игр может быть использована для поиска ошибок в коде.
</p>
</div>
</div>
<!-- EDIT37 SECTION "Кодирование исходного кода игры" [204189-205527] -->
<h2 class="sectionedit38" id="запаковка_ресурсов">Запаковка ресурсов</h2>
<div class="level2">

<p>
Вы можете упаковать ресурсы игры (графику, музыку, темы) в файл ресурсов <code>.idf</code>, для этого поместите все ресурсы в каталог <code>data</code> и запустите INSTEAD:
</p>

<p>
<code>sdl-instead -idf &lt;путь к data&gt;</code>
</p>

<p>
При этом, в текущем каталоге должен будет создастся файл <code>data.idf</code>. Поместите его в каталог с игрой. Теперь ресурсы игры в виде отдельных файлов можно удалить (конечно, оставив себе оригинальные файлы).
</p>

<p>
Вы можете запаковать в формат <code>.idf</code> всю игру:
</p>

<p>
<code>sdl-instead -idf &lt;путь к игре&gt;</code>
</p>

<p>
Игры в формате <code>idf</code> можно запускать как обычные игры <code>instead</code> (как если бы это были каталоги) а также из командной строки: 
</p>

<p>
<code>sdl-instead game.idf</code>
</p>

</div>
<!-- EDIT38 SECTION "Запаковка ресурсов" [205528-206611] -->
<h2 class="sectionedit39" id="переключение_между_игроками">Переключение между игроками</h2>
<div class="level2">

<p>
Вы можете создать игру с несколькими персонажами и время от времени переключаться между ними (см. <code>change_pl</code>). Но вы можете также использовать этот трюк для того, чтобы иметь возможность переключаться между разными типами инвентаря.
</p>

</div>
<!-- EDIT39 SECTION "Переключение между игроками" [206612-207098] -->
<h2 class="sectionedit40" id="использование_параметров_обработчика">Использование параметров обработчика</h2>
<div class="level2">

<p>
Пример кода.
</p>
<pre class="code lua">stone <span class="sy0">=</span> obj <span class="br0">&#123;</span>
	nam <span class="sy0">=</span> <span class="st0">'камень'</span><span class="sy0">;</span>
	dsc <span class="sy0">=</span> <span class="st0">'На краю лежит {камень}.'</span><span class="sy0">;</span>
	act <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span><span class="br0">&#41;</span>
		<span class="kw3">remove</span><span class="br0">&#40;</span><span class="st0">'stone'</span><span class="br0">&#41;</span><span class="sy0">;</span>
		p <span class="st0">'Я толкнул камень, он сорвался и улетел вниз...'</span><span class="sy0">;</span>
	<span class="kw1">end</span></pre>

<p>
Обработчик act мог бы выглядеть проще:
</p>
<pre class="code lua">	act <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="br0">&#41;</span>
		<span class="kw3">remove</span><span class="br0">&#40;</span>s<span class="br0">&#41;</span><span class="sy0">;</span>
		p <span class="st0">'Я толкнул камень, он сорвался и улетел вниз...'</span><span class="sy0">;</span>
	<span class="kw1">end</span></pre>

</div>
<!-- EDIT40 SECTION "Использование параметров обработчика" [207099-207658] -->
<h2 class="sectionedit41" id="таймер">Таймер</h2>
<div class="level2">

<p>
Для асинхронных событий, привязанных к реальному времени, в INSTEAD есть возможность использовать таймер. На самом деле, вам следует хорошо подумать, стоит ли в приключенческой игре использовать таймер. Обычно, игроком это воспринимается не слишком благосклонно. С другой стороны, таймер вполне можно использовать для управления музыкой или в оформительских целях.
</p>

<p>
Для использования таймера, вам следует подключить модуль «timer».
</p>
<pre class="code lua"><span class="kw3">require</span> <span class="st0">&quot;timer&quot;</span></pre>

<p>
Таймер программируется с помощью объекта <code>timer</code>.
</p>
<ul>
<li class="level1"><div class="li"> <code>timer:set(мс)</code> – задать интервал таймера в миллисекундах;</div>
</li>
<li class="level1"><div class="li"> <code>timer:stop()</code> – остановить таймер;</div>
</li>
</ul>

<p>
При срабатывании таймера, вызывается обработчик <code>game.timer</code>. Если game.timer возвращает пустое значение, сцена не перерисовывается. В противном случае, возвращаемое значение выводится как реакция.
</p>

<p>
Вы можете делать локальные для комнаты обработчики <code>timer</code>. Если в комнате объявлен обработчик <code>timer</code>, он вызывается вместо <code>game.timer</code>.
</p>

<p>
Например:
</p>
<pre class="code lua">game<span class="sy0">.</span>timer <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="br0">&#41;</span>
    set_sound<span class="br0">&#40;</span><span class="st0">'gfx/beep.ogg'</span><span class="br0">&#41;</span><span class="sy0">;</span>
    p <span class="br0">&#40;</span><span class="st0">&quot;Timer:&quot;</span><span class="sy0">,</span> <span class="kw3">time</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>
<span class="kw1">end</span>
&nbsp;
<span class="kw1">function</span> init<span class="br0">&#40;</span><span class="br0">&#41;</span>
    timer<span class="sy0">:</span>set<span class="br0">&#40;</span><span class="nu0">1000</span><span class="br0">&#41;</span> <span class="co1">-- раз в секунду</span>
<span class="kw1">end</span></pre>
<pre class="code lua">myroom <span class="sy0">=</span> room  <span class="br0">&#123;</span>
    entered <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="br0">&#41;</span>
        timer<span class="sy0">:</span>set<span class="br0">&#40;</span><span class="nu0">1000</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="kw1">end</span><span class="sy0">;</span>
    timer <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="br0">&#41;</span>
        timer<span class="sy0">:</span>stop<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
        walk <span class="st0">'myroom2'</span><span class="sy0">;</span>
    <span class="kw1">end</span><span class="sy0">;</span>
    nam <span class="sy0">=</span> <span class="st0">'Проверка таймера'</span><span class="sy0">;</span>
    dsc <span class="sy0">=</span> <span class="co2">[[Ждите.]]</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>

<p>
Состояние таймера попадает в файл сохранения, таким образом, вам не нужно заботиться о его восстановлении.
</p>
<div class="wrap_center wrap_round wrap_tip plugin_wrap">
<p>
Кроме того, в INSTEAD существует возможность отслеживать интервалы времени в миллисекундах. Для этого используйте функцию stead.ticks(). Функция возвращает число миллисекунд, прошедшее с момента старта игры.
</p>
</div>
</div>
<!-- EDIT41 SECTION "Таймер" [207659-210379] -->
<h2 class="sectionedit42" id="музыкальный_плеер">Музыкальный плеер</h2>
<div class="level2">

<p>
Вы можете написать для игры свой проигрыватель музыки, создав его на основе живого объекта, например:
</p>
<pre class="code lua"><span class="co1">-- играет треки в случайном порядке, начиная со 2-го</span>
mplayer <span class="sy0">=</span> obj <span class="br0">&#123;</span>
        tracks <span class="sy0">=</span> <span class="br0">&#123;</span><span class="st0">&quot;mus/astro2.mod&quot;</span><span class="sy0">,</span> 
                   <span class="st0">&quot;mus/aws_chas.xm&quot;</span><span class="sy0">,</span> 
                   <span class="st0">&quot;mus/dmageofd.xm&quot;</span><span class="sy0">,</span> 
                   <span class="st0">&quot;mus/doomsday.s3m&quot;</span><span class="br0">&#125;</span><span class="sy0">;</span>
	nam <span class="sy0">=</span> <span class="st0">'плеер'</span><span class="sy0">;</span>
	life <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="br0">&#41;</span>
                <span class="kw1">if</span> <span class="kw2">not</span> is_music<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="kw1">then</span>
	                <span class="kw1">local</span> n <span class="sy0">=</span> tracks<span class="br0">&#91;</span>rnd<span class="br0">&#40;</span><span class="sy0">#</span>s<span class="sy0">.</span>tracks<span class="br0">&#41;</span><span class="br0">&#93;</span>
			set_music<span class="br0">&#40;</span>n<span class="sy0">,</span> <span class="nu0">1</span><span class="br0">&#41;</span><span class="sy0">;</span>
		<span class="kw1">end</span>
	<span class="kw1">end</span><span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span>
lifeon<span class="br0">&#40;</span><span class="st0">'mplayer'</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
Ниже приводится пример более сложного плеера. Меняем трек только если он закончился или прошло более 2 минут и игрок перешел из комнаты в комнату. В каждом треке можно указать число проигрываний (0 - зацикленный трек):
</p>
<pre class="code lua"><span class="kw3">require</span> <span class="st0">&quot;timer&quot;</span>
global <span class="br0">&#123;</span> track_time <span class="sy0">=</span> <span class="nu0">0</span> <span class="br0">&#125;</span><span class="sy0">;</span>
&nbsp;
music_player <span class="sy0">=</span> obj <span class="br0">&#123;</span>
	nam <span class="sy0">=</span> <span class="st0">'player'</span><span class="sy0">;</span>
	var <span class="br0">&#123;</span> pos <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> <span class="br0">&#125;</span><span class="sy0">;</span>
	playlist <span class="sy0">=</span> <span class="br0">&#123;</span> <span class="st0">'01 Frozen sun.ogg'</span><span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span>
		<span class="st0">'02 Thinking.ogg'</span><span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span>
		<span class="st0">'03 Melancholy.ogg'</span><span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span>
		<span class="st0">'04 Everyday happiness.ogg'</span><span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span>
		<span class="st0">'10 Good morning again.ogg'</span><span class="sy0">,</span> <span class="nu0">1</span><span class="sy0">,</span>
		<span class="st0">'15 [Bonus track] The end (demo cover).ogg'</span><span class="sy0">,</span> <span class="nu0">1</span><span class="br0">&#125;</span><span class="sy0">;</span>
	life <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="br0">&#41;</span>
		<span class="kw1">if</span> is_music<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="kw2">and</span> <span class="br0">&#40;</span> track_time <span class="sy0">&lt;</span> <span class="nu0">120</span> <span class="kw2">or</span> <span class="kw2">not</span> player_moved<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#41;</span> <span class="kw1">then</span>
			<span class="kw1">return</span>
		<span class="kw1">end</span>
		track_time <span class="sy0">=</span> <span class="nu0">0</span>
                <span class="kw1">if</span> s<span class="sy0">.</span>pos <span class="sy0">==</span> <span class="nu0">0</span> <span class="kw1">then</span>
                        s<span class="sy0">.</span>pos <span class="sy0">==</span> <span class="nu0">1</span>
                <span class="kw1">else</span>
                        s<span class="sy0">.</span>pos <span class="sy0">=</span> s<span class="sy0">.</span>pos <span class="sy0">+</span> <span class="nu0">2</span>
                <span class="kw1">end</span>
		<span class="kw1">if</span> s<span class="sy0">.</span>pos <span class="sy0">&gt;</span> <span class="sy0">#</span>s<span class="sy0">.</span>playlist <span class="kw1">then</span>
			s<span class="sy0">.</span>pos <span class="sy0">=</span> <span class="nu0">1</span>
		<span class="kw1">end</span>
		set_music<span class="br0">&#40;</span><span class="st0">'mus/'</span><span class="sy0">..</span>s<span class="sy0">.</span>playlist<span class="br0">&#91;</span>s<span class="sy0">.</span>pos<span class="br0">&#93;</span><span class="sy0">,</span> s<span class="sy0">.</span>playlist<span class="br0">&#91;</span>s<span class="sy0">.</span>pos <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy0">;</span>
	<span class="kw1">end</span><span class="sy0">;</span>
<span class="br0">&#125;</span>
&nbsp;
game<span class="sy0">.</span>timer <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="br0">&#41;</span>
	track_time <span class="sy0">=</span> track_time <span class="sy0">+</span> <span class="nu0">1</span>
	music_player<span class="sy0">:</span>life<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="kw1">end</span>
&nbsp;
<span class="kw1">function</span> init<span class="br0">&#40;</span><span class="br0">&#41;</span>
        timer<span class="sy0">:</span>set<span class="br0">&#40;</span><span class="nu0">1000</span><span class="br0">&#41;</span>
<span class="kw1">end</span></pre>

</div>
<!-- EDIT42 SECTION "Музыкальный плеер" [210380-212322] -->
<h2 class="sectionedit43" id="живые_объекты">Живые объекты</h2>
<div class="level2">

<p>
Если вашему герою нужен друг, одним из способов может стать метод <code>life</code> этого персонажа, который всегда переносит объект в локацию игрока:
</p>
<pre class="code lua">horse <span class="sy0">=</span> obj <span class="br0">&#123;</span>
	nam <span class="sy0">=</span> <span class="st0">'лошадь'</span><span class="sy0">;</span>
	dsc <span class="sy0">=</span> <span class="st0">'Рядом со мной стоит {лошадь}.'</span><span class="sy0">;</span>
        act <span class="sy0">=</span> <span class="co2">[[Моя лошадка.]]</span><span class="sy0">;</span>
	life <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span>s<span class="br0">&#41;</span>
		<span class="kw1">if</span> player_moved<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="kw1">then</span>
			move<span class="br0">&#40;</span>s<span class="sy0">,</span> here<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">,</span> where<span class="br0">&#40;</span>s<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
		<span class="kw1">end</span>
	<span class="kw1">end</span><span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span>
<span class="kw1">function</span> init<span class="br0">&#40;</span><span class="br0">&#41;</span>
    put <span class="br0">&#40;</span>horse<span class="sy0">,</span> main<span class="br0">&#41;</span><span class="sy0">;</span> <span class="co1">-- только в этом случае where() будет работать</span>
    lifeon<span class="br0">&#40;</span>horse<span class="br0">&#41;</span><span class="sy0">;</span> <span class="co1">-- сразу оживим лошадь</span>
<span class="kw1">end</span></pre>

</div>
<!-- EDIT43 SECTION "Живые объекты" [212323-213043] -->
<h2 class="sectionedit44" id="клавиатура">Клавиатура</h2>
<div class="level2">

<p>
Вы можете перехватывать события клавиатуры с помощью модуля «kbd».
</p>

<p>
Обычно, перехват клавиш имеет смысл использовать для организации текстового ввода.
</p>

<p>
За описанием, обращайтесь к документации модуля «kbd».
</p>

</div>
<!-- EDIT44 SECTION "Клавиатура" [213044-213449] -->
<h2 class="sectionedit45" id="мышь">Мышь</h2>
<div class="level2">

<p>
Вы можете отслеживать в своей игре клики по картинке сцены, а также по фону. Для этого, воспользуйтесь модулем «click».
Также, вы можете отслеживать состояние мыши с помощью функции:
</p>
<pre class="code lua">stead<span class="sy0">.</span>mouse_pos<span class="br0">&#40;</span><span class="br0">&#91;</span>x<span class="sy0">,</span> y<span class="br0">&#93;</span><span class="br0">&#41;</span></pre>

<p>
Которая возвращает координаты курсора. Если задать параметры (x, y), то можно переместить курсор в указанную позицию (все координаты рассчитываются относительно левого верхнего угла окна INSTEAD).
</p>

</div>
<!-- EDIT45 SECTION "Мышь" [213450-214194] -->
<h2 class="sectionedit46" id="вызов_меню">Вызов меню</h2>
<div class="level2">

<p>
Вы можете вызвать из игры меню INSTEAD с помощью функции <code>stead.menu_toggle()</code>. Если в качестве параметра задать: &#039;save&#039;, &#039;load&#039; или &#039;quit&#039;, то будет вызван соответствующий подраздел меню.  (Поддерживается начиная с версии INSTEAD 1.8.3).
</p>

</div>
<!-- EDIT46 SECTION "Вызов меню" [214195-214610] -->
<h2 class="sectionedit47" id="динамическое_создание_объектов">Динамическое создание объектов</h2>
<div class="level2">

<p>
Как вы уже знаете, объекты нельзя создавать на лету, если только у них не определена функция <code>save</code>, которая сможет сохранить состояние такого объекта.
</p>

<p>
Тем не менее существует способ создание любого объекта на лету. Для этого вам понадобится написать <em>конструктор</em> вашего объекта и воспользоваться функцией <code>new</code>.
</p>

<p>
Итак, вы можете использовать функции <code>new</code> и <code>delete</code> для создания и удаления динамических объектов. 
Примеры:
</p>
<pre class="code lua"><span class="kw1">local</span> o <span class="sy0">=</span> new <span class="br0">&#40;</span><span class="co2">[[obj { nam = 'test', act = 'test' }]]</span><span class="br0">&#41;</span><span class="sy0">;</span>
take<span class="br0">&#40;</span>o<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="sy0">...</span>
put<span class="br0">&#40;</span>new <span class="co2">[[obj {nam = 'test' } ]]</span><span class="br0">&#41;</span><span class="sy0">;</span>
put<span class="br0">&#40;</span>new<span class="br0">&#40;</span><span class="st0">'myconstructor()'</span><span class="br0">&#41;</span><span class="sy0">;</span>
n <span class="sy0">=</span> new<span class="br0">&#40;</span><span class="st0">'myconstructor()'</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="sy0">...</span>
delete<span class="br0">&#40;</span>n<span class="br0">&#41;</span></pre>

<p>
<code>new</code> воспринимает строку-аргумент, как конструктор объекта. Результатом выполнения конструктора должен быть объект. Таким образом в аргументе обычно задан вызов функции-конструктора. Например:
</p>
<pre class="code lua"><span class="kw1">function</span> myconstructor<span class="br0">&#40;</span><span class="br0">&#41;</span>
	<span class="kw1">local</span> v <span class="sy0">=</span> <span class="br0">&#123;</span><span class="br0">&#125;</span>
	v<span class="sy0">.</span>nam <span class="sy0">=</span> <span class="st0">'тестовый объект'</span>
	v<span class="sy0">.</span>act <span class="sy0">=</span> <span class="st0">'Тестовая реакция'</span>
	<span class="kw1">return</span> obj<span class="br0">&#40;</span>v<span class="br0">&#41;</span>
<span class="kw1">end</span></pre>

<p>
Созданный объект будет попадать в файл сохранения. <code>new()</code> возвращает сам объект.
</p>

</div>
<!-- EDIT47 SECTION "Динамическое создание объектов" [214611-216309] -->
<h2 class="sectionedit48" id="запрет_на_сохранение_игры">Запрет на сохранение игры</h2>
<div class="level2">

<p>
Иногда может понадобиться запретить игроку делать сохранения в игре. Например, если речь идет о сценах, где важный элемент составляет случай, или для коротких игр, в которых проигрыш должен быть фатальным и требовать перезапуска игры.
</p>

<p>
Для управлением функции сохранения используется атрибут <code>game.enable_save</code>.
</p>

<p>
Например:
</p>
<pre class="code lua">game<span class="sy0">.</span>enable_save <span class="sy0">=</span> <span class="kw4">false</span> <span class="co1">-- запретить сохранения</span></pre>

<p>
Если вы хотите запрещать сохранения не везде, а в некоторых сценах, оформите <code>game.enable_save</code> в виде функции:
</p>
<pre class="code lua"><span class="co1">-- запретить сохранения в комнатах, которые содержат атрибут nosave.</span>
game<span class="sy0">.</span>enable_save <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">&#40;</span><span class="br0">&#41;</span> 
        <span class="kw1">if</span> here<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">.</span>nosave <span class="kw1">then</span>
                <span class="kw1">return</span> <span class="kw4">false</span>
        <span class="kw1">end</span>
        <span class="kw1">return</span> <span class="kw4">true</span>
<span class="kw1">end</span></pre>

<p>
Следует отметить, что запрет на сохранения не означает запрета на автосохранение. Для управления автосохранением воспользуйтесь аналогичным атрибутом <code>game.enable_autosave</code>.
</p>

<p>
Вы можете явно сохранять игру с помощью вызова: <code>autosave([номер слота])</code>; Если номер слота не задан, то игра будет сохранена под слотом &#039;автосохранение&#039;.
</p>

</div>
<!-- EDIT48 SECTION "Запрет на сохранение игры" [216310-218069] -->
<h1 class="sectionedit49" id="темы_для_sdl-instead">22. Темы для sdl-instead</h1>
<div class="level1">

<p>
Графический интерпретатор поддерживает механизм тем. <em>Тема</em> представляет из себя каталог, с файлом <code>theme.ini</code> внутри.
</p>

<p>
Тема, которая является минимально необходимой – это тема <code>default</code>. Эта тема всегда загружается первой. Все остальные темы наследуются от нее и могут частично или полностью заменять ее параметры. Выбор темы осуществляется пользователем через меню настроек, однако конкретная игра может содержать собственную тему и таким образом влиять на свой внешний вид. В этом случае в каталоге с игрой должен находиться свой файл <code>theme.ini</code>. Тем не менее, пользователь свободен отключить данный механизм, при этом интерпретатор будет предупреждать о нарушении творческого замысла автора игры.
</p>

<p>
Синтаксис <code>theme.ini</code> очень прост. 
</p>
<pre class="code ini">&lt;параметр&gt; <span class="sy0">=</span><span class="re2"> &lt;значение&gt; </span></pre>

<p>
или
</p>
<pre class="code ini"><span class="co0">; комментарий</span></pre>

<p>
Значения могут быть следующих типов: строка, цвет, число.
</p>

<p>
Цвет задается в форме #rgb, где r g и b компоненты цвета в шестнадцатеричном виде. Кроме того некоторые основные цвета распознаются по своим именам. Например: yellowgreen, или violet.
</p>

<p>
Параметры могут принимать значения:
</p>
<ul>
<li class="level1"><div class="li"> <code>scr.w</code> = ширина игрового пространства в пикселях (число)</div>
</li>
<li class="level1"><div class="li"> <code>scr.h</code> = высота игрового пространства в пикселях (число)</div>
</li>
<li class="level1"><div class="li"> <code>scr.col.bg</code> = цвет фона</div>
</li>
<li class="level1"><div class="li"> <code>scr.gfx.scalable</code> = [0|1|2] (0 - не масштабируемая тема, 1 - масштабируемая, 2 - кратно-масштабируемая)</div>
</li>
<li class="level1"><div class="li"> <code>scr.gfx.bg</code> = путь к картинке фонового изображения  (строка)</div>
</li>
<li class="level1"><div class="li"> <code>scr.gfx.cursor.x</code> = x координата центра курсора (число)</div>
</li>
<li class="level1"><div class="li"> <code>scr.gfx.cursor.y</code> = y координата центра курсора (число)</div>
</li>
<li class="level1"><div class="li"> <code>scr.gfx.cursor.normal</code> = путь к картинке-курсору (строка)</div>
</li>
<li class="level1"><div class="li"> <code>scr.gfx.cursor.use</code> = путь к картинке-курсору режима использования (строка)</div>
</li>
<li class="level1"><div class="li"> <code>scr.gfx.use</code> = путь к картинке-индикатору режима использования (строка)</div>
</li>
<li class="level1"><div class="li"> <code>scr.gfx.pad</code> = размер отступов к скролл-барам и краям меню (число)</div>
</li>
<li class="level1"><div class="li"> <code>scr.gfx.x</code>, <code>scr.gfx.y</code>, <code>scr.gfx.w</code>, <code>scr.gfx.h</code> = координаты, ширина и высота окна изображений. Области в которой располагается картинка сцены. Интерпретация зависит от режима расположения (числа)</div>
</li>
<li class="level1"><div class="li"> <code>win.gfx.h</code> - синоним <code>scr.gfx.h</code> (для совместимости) </div>
</li>
<li class="level1"><div class="li"> <code>scr.gfx.mode</code> = режим расположения (строка <code>fixed</code>, <code>embedded</code> или <code>float</code>). Задает режим изображения. <code>embedded</code> – картинка является частью содержимого главного окна, параметры <code>scr.gfx.x</code>, <code>scr.gfx.y</code>, <code>scr.gfx.w</code> игнорируются. <code>float</code> – картинка расположена по указанным координатам (scr.gfx.x, scr.gfx.y) и масштабируется к  размеру <code>scr.gfx.w</code> x <code>scr.gfx.h</code> если превышает его. <code>fixed</code> – картинка является частью сцены как в режиме embedded, но не скроллируется вместе с текстом а расположена непосредственно над ним. Доступны модификации режима float с модификаторами &#039;left/right/center/middle/bottom/top&#039;, указывающими как именно размещать картинку в области sct.gfx. Например: float-top-left;</div>
</li>
<li class="level1"><div class="li">  <code>win.scroll.mode</code> = [0|1|2|3] режим прокрутки области сцены. 0 - нет автоматической прокрутки, 1 - прокрутка на изменение в тексте, 2 прокрутка на изменение, только если изменение не видно, 3 - всегда в конец;</div>
</li>
<li class="level1"><div class="li"> <code>win.x</code>, <code>win.y</code>, <code>win.w</code>, <code>win.h</code> = координаты, ширина и высота главного окна. Области в которой располагается описание сцены (числа)</div>
</li>
<li class="level1"><div class="li"> <code>win.fnt.name</code> = путь к файлу-шрифту (строка). Здесь и далее, шрифт может содержать описание всех начертаний, например: {sans,sans-b,sans-i,sans-bi}.ttf (заданы начертания для regular, bold, italic и bold-italic). Вы можете опускать какие-то начертания, и движок сам сгенерирует их на основе обычного начертания, например: {sans,,sans-i}.ttf (заданы только regular и italic);</div>
</li>
<li class="level1"><div class="li"> <code>win.align</code> = center/left/right/justify (выравнивание текста в окне сцены);</div>
</li>
<li class="level1"><div class="li"> <code>win.fnt.size</code> = размер шрифта главного окна (размер)</div>
</li>
<li class="level1"><div class="li"> <code>win.fnt.height</code> = междустрочный интервал как число с плавающей запятой (1.0 по умолчанию)</div>
</li>
<li class="level1"><div class="li"> <code>win.gfx.up</code>, <code>win.gfx.down</code> = пути к файлам-изображениям скорллеров вверх/вниз для главного окна (строка)</div>
</li>
<li class="level1"><div class="li"> <code>win.up.x</code>, <code>win.up.y</code>, <code>win.down.x</code>, <code>win.down.y</code> = координаты скроллеров (координата или -1)</div>
</li>
<li class="level1"><div class="li"> <code>win.col.fg</code> = цвет текста главного окна (цвет)</div>
</li>
<li class="level1"><div class="li"> <code>win.col.link</code> = цвет ссылок главного окна (цвет)</div>
</li>
<li class="level1"><div class="li"> <code>win.col.alink</code> = цвет активных ссылок главного окна (цвет)</div>
</li>
<li class="level1"><div class="li"> <code>inv.x</code>, <code>inv.y</code>, <code>inv.w</code>, <code>inv.h</code> = координаты, высота и ширина области инвентаря. (числа)</div>
</li>
<li class="level1"><div class="li"> <code>inv.mode</code> = строка режима инвентаря (<code>horizontal</code> или <code>vertical</code>). В горизонтальном режиме инвентаря в одной строке могут быть несколько предметов. В вертикальном режиме, в каждой строке инвентаря содержится только один предмет. (число) Существует модификации (-left/right/center). Вы можете задать режим <code>disabled</code> если в вашей игре не нужен инвентарь;</div>
</li>
<li class="level1"><div class="li"> <code>inv.col.fg</code> = цвет текста инвентаря (цвет)</div>
</li>
<li class="level1"><div class="li"> <code>inv.col.link</code> = цвет ссылок инвентаря (цвет)</div>
</li>
<li class="level1"><div class="li"> <code>inv.col.alink</code> = цвет активных ссылок инвентаря (цвет)</div>
</li>
<li class="level1"><div class="li"> <code>inv.fnt.name</code> = путь к файлу-шрифту инвентаря (строка)</div>
</li>
<li class="level1"><div class="li"> <code>inv.fnt.size</code> = размер шрифта инвентаря (размер)</div>
</li>
<li class="level1"><div class="li"> <code>inv.fnt.height</code> = междустрочный интервал как число с плавающей запятой (1.0 по умолчанию)</div>
</li>
<li class="level1"><div class="li"> <code>inv.gfx.up</code>, <code>inv.gfx.down</code> = пути к файлам-изображениям скорллеров вверх/вниз для инвентаря (строка)</div>
</li>
<li class="level1"><div class="li"> <code>inv.up.x</code>, <code>inv.up.y</code>, <code>inv.down.x</code>, <code>inv.down.y</code> = координаты скроллеров (координата или -1)</div>
</li>
<li class="level1"><div class="li"> <code>menu.col.bg</code> = фон меню (цвет)</div>
</li>
<li class="level1"><div class="li"> <code>menu.col.fg</code> = цвет текста меню (цвет)</div>
</li>
<li class="level1"><div class="li"> <code>menu.col.link</code> = цвет ссылок меню (цвет)</div>
</li>
<li class="level1"><div class="li"> <code>menu.col.alink</code> = цвет активных ссылок меню (цвет)</div>
</li>
<li class="level1"><div class="li"> <code>menu.col.alpha</code> = прозрачность меню 0-255 (число)</div>
</li>
<li class="level1"><div class="li"> <code>menu.col.border</code> = цвет бордюра меню (цвет)</div>
</li>
<li class="level1"><div class="li"> <code>menu.bw</code> = толщина бордюра меню (число)</div>
</li>
<li class="level1"><div class="li"> <code>menu.fnt.name</code> = путь к файлу-шрифту меню (строка)</div>
</li>
<li class="level1"><div class="li"> <code>menu.fnt.size</code> = размер шрифта меню (размер)</div>
</li>
<li class="level1"><div class="li"> <code>menu.fnt.height</code> = междустрочный интервал как число с плавающей запятой (1.0 по умолчанию)</div>
</li>
<li class="level1"><div class="li"> <code>menu.gfx.button</code> = путь к файлу изображению значка меню (строка)</div>
</li>
<li class="level1"><div class="li"> <code>menu.button.x</code>, <code>menu.button.y</code> = координаты кнопки меню (числа)</div>
</li>
<li class="level1"><div class="li"> <code>snd.click</code> = путь к звуковому файлу щелчка (строка)</div>
</li>
<li class="level1"><div class="li"> <code>include</code> = имя темы (последний компонент в пути каталога) (строка)</div>
</li>
</ul>

<p>
Кроме того, заголовок темы может включать в себя комментарии с тегами. На данный момент существует только один тег: $Name:, содержащий UTF-8 строку с именем темы. Например:
</p>
<pre class="code ini"><span class="co0">; $Name:Новая тема$</span>
<span class="co0">; модификация темы book</span>
<span class="re1">include</span> <span class="sy0">=</span><span class="re2"> book -- использовать тему ''Книга''</span>
scr.gfx.h <span class="sy0">=</span><span class="re2"> 500 -- заменить в ней один параметр</span></pre>
<div class="wrap_center wrap_round wrap_info plugin_wrap">
<p>
Интерпретатор выполняет поиск тем в каталоге <code>themes</code>. Unix версия кроме этого каталога, просматривает также каталог <code>~/.instead/themes/</code>
Windows версия: <code>Documents and Settings/USER/Local Settings/Application Data/instead/themes</code>
</p>
</div>
</div>
<!-- EDIT49 SECTION "22. Темы для sdl-instead" [218070-] --></div>
</body>
</html>
